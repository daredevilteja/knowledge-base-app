{"docstore/metadata": {"e17b0c64-cd9f-41cf-abe9-a67210123a81": {"doc_hash": "0527169bc48860e9fc00ddb02cde9d6053816a5b1a5dcadf54768dd9978c770e"}, "0d19f0ac-00ca-448c-873e-bc6a715643d0": {"doc_hash": "a270d76087678f981204ce09a9b6b4cca2c21a0b1a6fed4ce65b83d10009ae55"}, "2e8d6e17-f630-4efa-a991-18098e483b6e": {"doc_hash": "f4700eeaacff1bcd25fcf5a2a52686fc7d125a97684632a1e446dde4b268b0e4"}, "7bcb053a-7806-48d6-8515-e407b7e89107": {"doc_hash": "c01467b73c2702bc2af83f16606a740e76c80fdf4fb33c3025ab1a3266a1165a"}, "cd58ec20-3daa-4bdf-ad88-fccae5b01bf6": {"doc_hash": "2ff38501f7d08dd8621c84421002781fe74458f000b80138b4cfbeb3a810691e"}, "ec7a2c48-3d51-42b1-93c7-8944c62d987a": {"doc_hash": "b43a2799b87a82c75147415f8e208e641d9940021b0d480f6c545c5e325aabbd"}, "a4cf75d4-4dd4-4848-ae4b-2eafbfc3825c": {"doc_hash": "e7be7e7a63e6e2e9eac126b99d4e9de0c757789437488810e157a223f8c9040f"}, "5ebf8bf6-9020-44f6-879b-a4c6c8c7c931": {"doc_hash": "e7cd603ff5dcad820382963c204fdeee8904885ed676765f8a9e6c64648714df"}, "c0febe2b-4398-4228-ac1c-5b1b22605cd1": {"doc_hash": "d0de34754a6357447aff3fc534b1cba796976ef58d29bb49ea7b450d8fd661e7"}, "bd097c64-5d9b-4a18-96bb-6e7a277f6bb1": {"doc_hash": "1895c14815f99a2762c5251bb4cfdd51e920541298398aa26ca00a2ea4e47214"}, "b415e45a-18ae-49cd-8c7e-084a1782fb49": {"doc_hash": "b3f68110625750f0213aca10b47f881b5b09ea378ca58d690b4541c0d731fb05"}, "9a8cadb3-8c39-45e8-8361-ae7fc4f77539": {"doc_hash": "0f289da5f37a8f537f2aa30ba36e18f9ca7496065d938140570e87d14464b6c4"}, "17e4b40b-36a3-4fbf-bd6c-187c30472a3b": {"doc_hash": "5935e48b690c3fb01b291023c72677c5e1ca4964fc4c3608a356e52183097c94"}, "e353ca95-83c9-4941-acf7-2839c51a7743": {"doc_hash": "2df204576fa377b8e254c57195854dfc9cee09b82133cf73764316fa97599f23"}, "353a5383-fb34-47a7-8a88-847b2bacf0bc": {"doc_hash": "ec9ed7f27060743a9f3eed7d2ffe7429edceec8ff2f50749ce3c419d6c679421"}, "7dff9daf-6ab4-4a16-ae04-f62216c42514": {"doc_hash": "a1551bc435b8ed2cad277cb166894f436248dcca4b1de18450fb64456af56f5e"}, "3997a495-20e0-4c1f-a940-e55e3ef3a1b2": {"doc_hash": "2f6bab0f0d6c5cd8ac3d4df9cab58d32ff9f88c7e823c36fb10c482e8bebd532"}, "93247a89-3d19-498c-b935-a0d1a8bf16ef": {"doc_hash": "ee87438ac6fe3073b7acd65837b53c41a70a703e9dc1e3c83b4b47fffceaf8ec"}, "35fb1684-4a20-4e7f-a374-eac16b8a42b4": {"doc_hash": "c2dc3f7c5682fe018a7a8f524847f1c03af58f041d6cc94367ff5d58094cbecc"}, "fd92e2aa-987b-42b9-8b0f-7ba363da2ace": {"doc_hash": "ec713a31fe45ff1cd47a9f38021a27029ade52d1800ad214f85f70ab5d829769"}, "8d10acbf-4785-41b5-bb15-29428240f49b": {"doc_hash": "0527169bc48860e9fc00ddb02cde9d6053816a5b1a5dcadf54768dd9978c770e", "ref_doc_id": "e17b0c64-cd9f-41cf-abe9-a67210123a81"}, "387325e3-7ce0-4b20-8fd9-c6c5d590babf": {"doc_hash": "a270d76087678f981204ce09a9b6b4cca2c21a0b1a6fed4ce65b83d10009ae55", "ref_doc_id": "0d19f0ac-00ca-448c-873e-bc6a715643d0"}, "d985c931-26d8-41db-9d80-f6f92bd6ef31": {"doc_hash": "f4700eeaacff1bcd25fcf5a2a52686fc7d125a97684632a1e446dde4b268b0e4", "ref_doc_id": "2e8d6e17-f630-4efa-a991-18098e483b6e"}, "3cb0172f-8f4e-4022-ab14-e9e007485b0f": {"doc_hash": "c01467b73c2702bc2af83f16606a740e76c80fdf4fb33c3025ab1a3266a1165a", "ref_doc_id": "7bcb053a-7806-48d6-8515-e407b7e89107"}, "0244ebf4-5d48-450d-a22d-e83d36ae94e2": {"doc_hash": "2ff38501f7d08dd8621c84421002781fe74458f000b80138b4cfbeb3a810691e", "ref_doc_id": "cd58ec20-3daa-4bdf-ad88-fccae5b01bf6"}, "203f6855-7fcd-4404-bd51-41087cac207b": {"doc_hash": "b43a2799b87a82c75147415f8e208e641d9940021b0d480f6c545c5e325aabbd", "ref_doc_id": "ec7a2c48-3d51-42b1-93c7-8944c62d987a"}, "fdad0bae-c99d-4711-861c-6b3d2b057c82": {"doc_hash": "e7be7e7a63e6e2e9eac126b99d4e9de0c757789437488810e157a223f8c9040f", "ref_doc_id": "a4cf75d4-4dd4-4848-ae4b-2eafbfc3825c"}, "b9b64d9a-ec67-4eb9-95ad-344e148821f5": {"doc_hash": "e7cd603ff5dcad820382963c204fdeee8904885ed676765f8a9e6c64648714df", "ref_doc_id": "5ebf8bf6-9020-44f6-879b-a4c6c8c7c931"}, "ab7e2450-8880-4ff4-ac81-11e6c8cd9ef7": {"doc_hash": "d0de34754a6357447aff3fc534b1cba796976ef58d29bb49ea7b450d8fd661e7", "ref_doc_id": "c0febe2b-4398-4228-ac1c-5b1b22605cd1"}, "48aa1494-434e-4a93-90ce-5cc22e36b23e": {"doc_hash": "1895c14815f99a2762c5251bb4cfdd51e920541298398aa26ca00a2ea4e47214", "ref_doc_id": "bd097c64-5d9b-4a18-96bb-6e7a277f6bb1"}, "01e2dc84-a538-4b8e-8a3e-0545254b5237": {"doc_hash": "b3f68110625750f0213aca10b47f881b5b09ea378ca58d690b4541c0d731fb05", "ref_doc_id": "b415e45a-18ae-49cd-8c7e-084a1782fb49"}, "316d24eb-6214-4da2-8a37-00e4b83227e8": {"doc_hash": "0f289da5f37a8f537f2aa30ba36e18f9ca7496065d938140570e87d14464b6c4", "ref_doc_id": "9a8cadb3-8c39-45e8-8361-ae7fc4f77539"}, "ed0c8f42-61f7-4f9b-91ca-dc4ed3e8a335": {"doc_hash": "5935e48b690c3fb01b291023c72677c5e1ca4964fc4c3608a356e52183097c94", "ref_doc_id": "17e4b40b-36a3-4fbf-bd6c-187c30472a3b"}, "45ed8b2d-f078-4803-ab8f-56862cc194b0": {"doc_hash": "2df204576fa377b8e254c57195854dfc9cee09b82133cf73764316fa97599f23", "ref_doc_id": "e353ca95-83c9-4941-acf7-2839c51a7743"}, "b5329123-7c2c-4ccb-bbfd-c9ddf9c9d8a1": {"doc_hash": "ec9ed7f27060743a9f3eed7d2ffe7429edceec8ff2f50749ce3c419d6c679421", "ref_doc_id": "353a5383-fb34-47a7-8a88-847b2bacf0bc"}, "46df02a2-3955-4c1d-878b-b4cd7a23e0dd": {"doc_hash": "a1551bc435b8ed2cad277cb166894f436248dcca4b1de18450fb64456af56f5e", "ref_doc_id": "7dff9daf-6ab4-4a16-ae04-f62216c42514"}, "595efc0e-9f6f-4445-959e-e8c9ac32fbbd": {"doc_hash": "2f6bab0f0d6c5cd8ac3d4df9cab58d32ff9f88c7e823c36fb10c482e8bebd532", "ref_doc_id": "3997a495-20e0-4c1f-a940-e55e3ef3a1b2"}, "1d150695-1c81-4b6c-94ea-ea2f4c14b745": {"doc_hash": "ee87438ac6fe3073b7acd65837b53c41a70a703e9dc1e3c83b4b47fffceaf8ec", "ref_doc_id": "93247a89-3d19-498c-b935-a0d1a8bf16ef"}, "ec950c06-ba9e-4ba6-ac1c-86921d56d6f1": {"doc_hash": "c2dc3f7c5682fe018a7a8f524847f1c03af58f041d6cc94367ff5d58094cbecc", "ref_doc_id": "35fb1684-4a20-4e7f-a374-eac16b8a42b4"}, "50e80d53-dfc3-402b-96f9-6ff0c7420f68": {"doc_hash": "ec713a31fe45ff1cd47a9f38021a27029ade52d1800ad214f85f70ab5d829769", "ref_doc_id": "fd92e2aa-987b-42b9-8b0f-7ba363da2ace"}}, "docstore/data": {"8d10acbf-4785-41b5-bb15-29428240f49b": {"__data__": {"id_": "8d10acbf-4785-41b5-bb15-29428240f49b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "e17b0c64-cd9f-41cf-abe9-a67210123a81", "node_type": null, "metadata": {}, "hash": "0527169bc48860e9fc00ddb02cde9d6053816a5b1a5dcadf54768dd9978c770e"}}, "hash": "0527169bc48860e9fc00ddb02cde9d6053816a5b1a5dcadf54768dd9978c770e", "text": "What is the significance of Suspense for React?<div><div><figure></figure><p>Many of you may not have used <strong>Suspense</strong> in your projects, but Suspense is a very important part of React\u2019s future development.</p><p>This article will explain the significance of Suspense for React.</p><h2>React\u2019s an iterative process</h2><p><strong>React</strong> has undergone three major changes in its main features from v16 to v18:</p><ul><li>v16\uff1aAsync Mode</li><li>v17\uff1aConcurrent Mode</li><li>v18\uff1aConcurrent Render</li></ul><p>The main feature of React from v16 to v18 has undergone three major changes: to understand the significance of these three changes, you need to first understand a very confusing concept in React \u2014 <strong>render</strong>.</p><p>The render function of a ClassComponent is called render when it is executed\uff1a</p><pre>class App extends Component {<br /> render() {<br /> // <br /> }<br />}</pre><p>And the process of rendering the result of render to the page is called commit.</p><p>The purpose of Async Mode is to make rendering asynchronous and interruptible.</p><p>The purpose of Concurrent Mode is to make commit concurrent in the user\u2019s perception.</p><p>Since Concurrent Mode includes breaking change, v18 proposes Concurrent Render to reduce the cost of migration for developers.</p><p>So what does \u201cmaking commit concurrent in user\u2019s perception\u201d mean?</p><h2>The meaning of \u201cconcurrency\u201d</h2><p>When it comes to \u201cconcurrency\u201d, we have to mention Suspense. consider the following code:</p><pre>const App = () =&gt; {<br /> const [count, setCount] = useState(0);<br /> useEffect(() =&gt; {<br /> setInterval(() =&gt; {<br /> setCount(count =&gt; count + 1);<br /> }, 1000);<br /> }, []);<br /> return (<br /> &lt;&gt;<br /> &lt;Suspense fallback={&lt;div&gt;loading...&lt;/div&gt;}&gt;<br /> &lt;Sub count={count} /&gt;<br /> &lt;/Suspense&gt;<br /> &lt;div&gt;count is {count}&lt;/div&gt;<br /> &lt;/&gt;<br /> );<br />};</pre><ul><li>An update will be triggered every second, updating the state count to count =&gt; count + 1</li><li>In Sub, an asynchronous request is initiated, and before the request returns, the Suspense wrapping Sub renders the fallback</li></ul><p>Assuming the request returns in three seconds, ideally, the page before and after the request is initiated will be displayed in order as:</p><pre>// Before the request is initiated within Sub<br />&lt;div class=\u201csub\u201d&gt;I am sub, count is 0&lt;/div&gt;<br />&lt;div&gt;count is 0&lt;/div&gt;// The first second of request initiation within Sub<br />&lt;div&gt;loading...&lt;/div&gt;<br />&lt;div&gt;count is 1&lt;/div&gt;// Sub request initiated in the 2nd second<br />&lt;div&gt;loading...&lt;/div&gt;<br />&lt;div&gt;count is 2&lt;/div&gt;// Request initiated in Sub at 3 seconds<br />&lt;div&gt;loading...&lt;/div&gt;<br />&lt;div&gt;count is 3&lt;/div&gt;// After a successful request within Sub<br />&lt;", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "387325e3-7ce0-4b20-8fd9-c6c5d590babf": {"__data__": {"id_": "387325e3-7ce0-4b20-8fd9-c6c5d590babf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "0d19f0ac-00ca-448c-873e-bc6a715643d0", "node_type": null, "metadata": {}, "hash": "a270d76087678f981204ce09a9b6b4cca2c21a0b1a6fed4ce65b83d10009ae55"}}, "hash": "a270d76087678f981204ce09a9b6b4cca2c21a0b1a6fed4ce65b83d10009ae55", "text": "React 18 \u2014 What\u2019s New!<div><div><p>Everything New In React 18</p><figure><figcaption>React 18 new features</figcaption></figure><p>React 17 was a bit of a bore for developers. There really wasn\u2019t a lot added but it\u2019s definitely not the case with react 18. In this article, I will tell you some of the top updates and show you how to get started using React 18 alpha today. Links to everything mentioned will be below.</p></div><div><p>With React 18 there\u2019s a new Root API. Here\u2019s what you\u2019re used to seeing. We pass <strong>ReactDom.render </strong>our app component and then <strong>document.getElementById</strong> and our root element. So we\u2019re rendering our app component into our root element on the page. Pretty Simple!</p><figure></figure><p>Here\u2019s a new way. We have a root variable that is equal to a new method called <strong>create root</strong>. This is being passed our root element and then we call <strong><em>root.render</em></strong> and pass our app component.</p><figure></figure><p>It\u2019s accomplishing the same thing but differently. The old way is now called the <strong>Legacy Root API</strong> and It\u2019s still going to work in React 18 but will be deprecated at some point by using the new Root API. You\u2019re going to get access to all of the React 18 improvements including the concurrent features that we\u2019re going to talk about in this article.</p><h2><strong>Suspense</strong></h2><p>The suspense is finally over in this update we\u2019re going to get full support for suspense. Now, what is suspense? As the name implies it suspends something until it\u2019s ready to be rendered.</p><p>In this example, we have a component that needs time to fetch data before it\u2019s ready to be rendered.</p><figure></figure><p>The suspense will use the <em>fallback</em> until the data is returned and the components are rendered. It\u2019s important to note here that the random component here is not waiting on data, but it will still be suspended until everything inside the suspense is ready to be rendered.</p><p>And now the suspense is going to be extremely useful with <strong>SSR</strong> or <strong>Server Side Rendering</strong>. Currently, with SSR you\u2019re going to get <strong>fully rendered HTML</strong> but your browser still has to load the JavaScript and hydrate the entire page before it can become interactive. Suspense could speed up this load time dramatically.</p><p>Using the <strong>React 18</strong> working group repo example, we have a page loading a navbar, a sidebar, a post, and a comment.</p><figure></figure><p>Now we really don\u2019t need the comments to load before the site becomes interactive. So we\u2019re going to suspend the comments. So that the viewer can start reading the article and then we\u2019ll load the comments in the background.</p><p>Another cool thing about suspense is selective <strong>hydration</strong>.</p><figure></figure><p>In this example., we\u2019re suspending the sidebar and the comments. Hydration will begin on the first suspended component in the tree. So the sidebar will hydrate first but if the user tries to interact with the comments section, React will prioritize hydrating the comments instead of the sidebar.</p><h2><strong>Automatic Batching</strong></h2><p>In React 17 and earlier react with batch re-render updates during a browser event like a click. Here\u2019s an example from the docs.</p><figure></figure><p>So in this handle click react will batch these two state updates into one single re-render.</p><figure></figure><p>But if you need to <em>fetch data</em> and then update the state these re-renders <strong>will not be batched</strong>.</p><p>With react 18, If you\u2019re using the new <strong><em>Create Root API</em></strong>, all state updates will automatically be batched no matter when they happen. If you do have a critical component that you don\u2019t want", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "d985c931-26d8-41db-9d80-f6f92bd6ef31": {"__data__": {"id_": "d985c931-26d8-41db-9d80-f6f92bd6ef31", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2e8d6e17-f630-4efa-a991-18098e483b6e", "node_type": null, "metadata": {}, "hash": "f4700eeaacff1bcd25fcf5a2a52686fc7d125a97684632a1e446dde4b268b0e4"}}, "hash": "f4700eeaacff1bcd25fcf5a2a52686fc7d125a97684632a1e446dde4b268b0e4", "text": "An unusual usage of React Suspense<div><div><figure><figcaption>Photo by <a href=\"https://unsplash.com/@kaip?utm_source=medium&amp;utm_medium=referral\">Kai Pilger</a> on <a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><h2>What is React Suspense?</h2><p>It\u2019s a mechanism making it possible to postpone the rendering of certain child components depending on some condition. Right now, it\u2019s widely used to implement lazy loading. While an expensive component is being fetched, there may be some fallback displayed in a form of an animated spinner or other loading indicator.</p><figure></figure><h2>How do you make your components Suspense-worthy?</h2><p>Actually, it\u2019s very simple. It turns out that as long as your components throw promise during render, you\u2019re good to go. Suspense will wait for it to resolve and then render your component normally. Anything other than promise will normally trigger error boundaries or, in the worst case, will cause the application to crash. This behavior has really interesting appliances.</p><p>Unfortunately, throwing during rendering means effects won\u2019t be executed, so you need to control suspension state through a prop. In other words, suspension must be controlled by the parent.</p><figure></figure><h2>Why would I do that?</h2><p>Let\u2019s say we are developing a mobile application using React Native. There are multiple screens relying on Redux (or some other global storage) and receiving updates in real time. We are using stack navigation, so every screen is put on stack when the user navigates further and then popped when he decides to go back. If updates are frequent and causing long, expensive renders, it would be nice to be able to halt them or, in other words, freeze affected screens.</p><h2>Does any production-grade library use this scheme?</h2><p>The code snippet I attached earlier comes from the <a href=\"https://github.com/software-mansion/react-freeze\">react-native-freeze</a> library created by really talented guys from <a href=\"https://swmansion.com/\">Software Mansion</a>. It\u2019s now natively supported in <a href=\"https://github.com/software-mansion/react-native-screens\">react-native-screens</a> and can be used to freeze screens in the background, stopping their execution and saving precious computation power. Keep in mind that you have to be using React v17 or React Native 0.64 at least to use it. If you end up using it, remember to leave a star in their repository!</p><h2>Suspense in the future</h2><p>React Suspense receives more and more attention with every new release on React. It\u2019s been recently upgraded to support the brand-new concurrent mode shipped with v18, so its use-cases are now not only limited to dynamic components and lazy-loading. If you would like to know more, I recommend checking <a href=\"https://reactjs.org/blog/2022/03/29/react-v18.html\">the official release notes</a> for details or waiting for another article of mine uncovering the secrets of React internals.</p></div>", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "3cb0172f-8f4e-4022-ab14-e9e007485b0f": {"__data__": {"id_": "3cb0172f-8f4e-4022-ab14-e9e007485b0f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "7bcb053a-7806-48d6-8515-e407b7e89107", "node_type": null, "metadata": {}, "hash": "c01467b73c2702bc2af83f16606a740e76c80fdf4fb33c3025ab1a3266a1165a"}}, "hash": "c01467b73c2702bc2af83f16606a740e76c80fdf4fb33c3025ab1a3266a1165a", "text": "Suspense in React 18: How it works, and how you can use it<div><div>\n<p>React 18, also known as the Concurrent React, released earlier this year and brought with it important changes. The most impactful one is the new concurrent rendering engine, which is what the new Concurrent Rendering feature \u201cSuspense\u201d is based on. If your React apps work with any asynchronous data sources (like REST services), using Suspense will not only make your apps easier to program, but those apps will also perform much better for your users.<br />\n</p>\n<p>In this article, we explain the basics of what Suspense is, as well as make clear what is currently supported in React 18, as well as what\u2019s not ready yet for production.<br />\n</p>\n<h2>What is Suspense, and Do I Need It?<br />\n</h2>\n<p>Suspense is the first feature released by the Facebook React team that takes advantage of the new concurrent rendering engine built into React 18. It allows you to build apps with more responsive UIs that use less browser resources. It also gives developers and designers a more intuitive API to work with.</p>\n<p>Suspense has been in the making for over three years, and it fundamentally changes how React determines what to render on a web page, based on your app\u2019s component state changes. If your React app data (aka state data) changes - and these changes do not require a full page rerender from the server - the React rendering engine does the necessary updates to the UI.</p>\n<p>An example of the difference between <a href=\"https://17.reactjs.org/docs/concurrent-mode-intro.html\">Concurrent React</a>, rendering a page, and the React rendering engine prior is what happens when a web page updates a list based on some interruption (like typing in a text box that is used as a filter item on a list).\u00a0</p>\n<p>Without Concurrent Rendering, it's possible that many of the items in the list will get updated by React. This makes the page feel sluggish to the user, and the browser uses a lot of computer resources to make the app work at all.\u00a0</p>\n<p>If your browser allows you to view the animated gif below, this is what you might see.</p>\n</div><div>\n<p>If, on the same computer, you were using an app that implemented Concurrent Rendering \u2014 meaning that as the user typed into the search box, only what was necessary in the DOM was updated \u2014 you might see a UI that performs like the one below.</p>\n</div><div>\n<h2>How Suspense Changes How You Implement Showing Data</h2>\n<h3>Without Suspense</h3>\n<p>Let's assume you have some kind of external data source such as a remote web service, or even just data from a <a href=\"https://en.wikipedia.org/wiki/Representational_state_transfer\">REST</a> Server. Without using Suspense and Concurrent Rendering \u2014 which, by the way, is still an option in React 18 \u2014 you\u2019d programmatically fetch the data, then check some data loading state, and finally, when that loading state indicates the data is fully retrieved, show the data in the UI.\u00a0</p>\n<p>Your app code probably looks something like this:</p>\n</div><div>\n<h3>With Suspense</h3>\n<p>If you were to do the same thing with React 18 Suspense using Concurrent Rendering, you\u2019d do things a bit differently.\u00a0</p>\n<p>Instead of using just a single component, you\u2019d first create another component that wraps the rendering part of this component inside a new Suspense Element. Then, as an attribute to the Suspense element, you'd pass a fallback attribute, and that attribute would get assigned to a fallback UI that gets displayed when the data the component is not available to render (meaning it has not been completely returned from an external source).\u00a0</p>\n<p>Roughly, the code might now look something like this:</p>\n</div><div>\n<p>What's happening here, is the line of code <i>const specialPromiseResource = getSpecialPromiseTofetchCities()</i> is executed outside of our Suspense component, and it requests the data", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "0244ebf4-5d48-450d-a22d-e83d36ae94e2": {"__data__": {"id_": "0244ebf4-5d48-450d-a22d-e83d36ae94e2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cd58ec20-3daa-4bdf-ad88-fccae5b01bf6", "node_type": null, "metadata": {}, "hash": "2ff38501f7d08dd8621c84421002781fe74458f000b80138b4cfbeb3a810691e"}}, "hash": "2ff38501f7d08dd8621c84421002781fe74458f000b80138b4cfbeb3a810691e", "text": "Understanding the Suspense API in React 18<div><div><p></p><h2>What is the new ReactJS Suspense API and when should you use it?</h2><p></p><figure><figcaption>Photo by <a href=\"https://unsplash.com/@mike_van_den_bos?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Mike van den Bos</a> on <a href=\"https://unsplash.com/s/photos/loading?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Unsplash</a></figcaption></figure><p>When components start to get big and you have many of them on the same page, you might want to start optimizing the way and the moment they get downloaded into your client\u2019s browser.</p><p>For that React provides you with the <code>lazy</code> method, which allows you to mark components as \u201clazy\u201d. This in turn means they get downloaded the first time they\u2019re used and not before.</p><p>This is a fantastic way to decrease the \u201ctime to first pixel\u201d and other metrics that measure the amount of time your app takes to render for the first time and the time it takes to be \u201cready\u201d for interactions.</p><p>But when you use this optimization, you run into a bit of a problem: what happens if the component takes too long to download? Especially in slow connection environments, this can be a problem.</p><p>What should your app show? How can you let your user know that something is happening even though they can\u2019t see it?</p><p>That\u2019s where the Suspense API comes into play, so let\u2019s take a look at it!</p></div><div><h2>What is the Suspense API?</h2><p>The Suspense API works in conjunction with \u201clazy\u201d components to let your users know that they\u2019re loading something in the background, while they\u2019re loading it.</p><p>It does so by providing an alternative visualization (a different component) while the slow, lazy component is being downloaded for the first time.</p><p>The premise here is that this alternative component is a low smaller and most likely can be reused in many different places. That way the trade-off makes sense.</p><p>Think about Suspense as a way to show the \u201cloading\u2026\u201d message, the spinning wheel or even the type of skeleton component while the actual one is being processed and downloaded.</p><p>Using requires you to simply wrap your lazy components with the <code>Suspense</code> one while specifying the <code>fallback</code> property. Like this:</p><figure></figure><p>As you can see, both the <code>Text</code> and <code>Buttons</code> components are lazy, and loading either of them will require a request to the server. The \u201cToggle\u201d link simply alternates between both of them.</p><p>Now the interesting bit here is that the <code>Suspense</code> component doesn\u2019t have to directly wrap the lazy components. They can be many levels down the tree, and the fallback would be shown anyway. So you don\u2019t have to worry about wrapping every single component with it, you can wrap a whole section of your component tree and have them all use the same fallback.</p><figure></figure><p>Look at the above GIF, it starts off with a white screen because it\u2019s slowly (notice the Slow 3G setting on the Network tab) downloading the initial page. Immediately after, you\u2019ll see the \u201cWaiting for content\u2026\u201d message, that\u2019s the <code>Waiting</code> fallback.</p><p>Then it gets replaced by a text message, that\u2019s the <code>Text</code> component that was loaded. We\u2019re seeing here the Suspense API in action.</p><p>Then when I click on the \u201cToggle\u201d link, you\u2019ll see the \u201cWaiting for content\u2026\u201d message again for a few seconds, while the browser is downloading", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "203f6855-7fcd-4404-bd51-41087cac207b": {"__data__": {"id_": "203f6855-7fcd-4404-bd51-41087cac207b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ec7a2c48-3d51-42b1-93c7-8944c62d987a", "node_type": null, "metadata": {}, "hash": "b43a2799b87a82c75147415f8e208e641d9940021b0d480f6c545c5e325aabbd"}}, "hash": "b43a2799b87a82c75147415f8e208e641d9940021b0d480f6c545c5e325aabbd", "text": "Understanding Suspense-ful coding in React<div><div><p><strong>TLDR; <code>&lt;Suspense&gt;</code> is cool and a useful way to handle async loads in your React apps, but it has some tricky gotchas about data flow and caching if you try to use it with bare <code>Promise</code>s. An easy way to solve this and use Suspense today is <a href=\"https://github.com/zackdotcomputer/suspension\">suspension</a>.</strong></p>\n<hr />\n<p>I've been working this week on a little webapp to practice integrating React apps with Firebase backends. As part of this project, I pulled in <a href=\"https://github.com/FirebaseExtended/reactfire\">reactfire</a>, which is the first module I've used that had first class support for the new React <code>&lt;Suspense&gt;</code> component. I'd heard about this component before but it was finally time to do a deep dive into what it was, how it worked, and how I could integrate it more deeply into my React apps going forward.</p>\n<h2>What is Suspense?</h2>\n<p>Suspense was the first component from React's <a href=\"https://reactjs.org/docs/concurrent-mode-suspense.html\">experimental Concurrent mode</a> to be merged into the non-experimental release (way back in 16.6). Suspense's job is to detect the need for an async load and render a fallback loading UI.</p>\n<pre><code>function CalendarApp() {\n const [viewedDay, setViewedDay] = useState(new Date());\n // Assuming that CalendarDayView is ready to work with Suspense,\n // this renders your loading spinner while today's data is loading.\n return (&lt;main&gt;\n &lt;Suspense fallback={&lt;LoadingSpinner /&gt;}&gt;\n &lt;CalendarDayView date={viewedDay} /&gt;\n &lt;/Suspense&gt;\n &lt;/main&gt;);\n}\n</code></pre>\n<p>If that was all it did, it would be basically syntactic sugar over the tried-and-true pattern of <code>if (callStatus === \"loading\") { return &lt;LoadingSpinner /&gt;; }</code>. But Suspense has a superpower that very few people are talking about, but to understand it we have to first understand how this component works.</p>\n<h2>How does Suspense work?</h2>\n<p>Suspense works by mildly abusing the <code>throw</code> statement. A component or hook that wants to indicate that it is still loading and needs more time should <code>throw</code> a <code>Promise</code> that will resolve when the component is ready for its render to be reattempted.</p>\n<pre><code>function CalendarDayView({ date }) {\n // Let's imagine our ORM has a cache of days' agendas we can check\n const cacheResult = calendarDB.cachedValue({ date });\n // To hook into Suspense, we recognize if we need to load and\n // throw a Promise that resolves when we're ready to try again.\n if (!cacheResult) {\n const loadingPromise = calendarDB.load({ date });\n loadingPromise.then((result) =&gt; {\n calendarDB.cache({ date, value: result });\n });\n throw loadingPromise;\n }\n // Otherwise do the render\n return (\n &lt;h1&gt;Calendar for {cacheResult.dayString}&lt;/h1&gt;\n // ... and so on\n );\n}\n</code></pre>\n<p>When we <code>throw</code> a Promise like this, React climbs the virtual DOM to find the nearest <code>&lt;Suspense&gt;</code> component and hands it the Promise.</p>\n<p><strong>This removes the whole tree under that Suspense from the rendered DOM and replaces it with the <code>fallback</code>.</strong></p>\n<p>This is how Suspense can give us superpowers. Because the <code>throw</code> interrupts our component's render process, we are guaranteed that if we get past it we are not loading", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "fdad0bae-c99d-4711-861c-6b3d2b057c82": {"__data__": {"id_": "fdad0bae-c99d-4711-861c-6b3d2b057c82", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a4cf75d4-4dd4-4848-ae4b-2eafbfc3825c", "node_type": null, "metadata": {}, "hash": "e7be7e7a63e6e2e9eac126b99d4e9de0c757789437488810e157a223f8c9040f"}}, "hash": "e7be7e7a63e6e2e9eac126b99d4e9de0c757789437488810e157a223f8c9040f", "text": "React Gets First Class Support for Async/Await \u2014 Yay or Meh?<div><div><p></p><h2>A look into the React RFC Draft proposal support for data loading</h2><p></p><figure><figcaption>Image by Author</figcaption></figure><p>The first cornerstone of React\u2019s first-class support for Async/Await started when the team introduced <code>Suspense</code> on React <code>16.6</code>. Back then, there was still no concurrent mode and its functionality was limited. The suspended component would render and just be hidden on the DOM. It was known as <code>Legacy Suspense</code>.</p><p>The <code>Suspense</code> was to become an important mechanism on which all the other APIs would rely.</p><p>When concurrent mode landed, the <code>Suspense</code> API was enhanced:</p><ul><li>The execution of the React Component is \u201cpaused\u201d. The <code>Element</code> is not mounted until the <code>ComponentThatSuspends</code> is resolved.</li><li>Effects/Lifecycle are fired properly.</li></ul><p>As of today, lazy loading components is the only use case supported by <code>Suspense</code>. The React team has been spending a long time figuring out how to blend data loading with <code>Suspense</code>. In this published RFC Draft, we can finally see how they plan to build it.</p><h2>Suspense for Data Fetching</h2><p>The approach the React team is taking is quite conventional, but with a twist.</p><p>They have chosen to implement this feature in two flavors:</p><ul><li>React Client: by introducing a <code>use</code> hook</li><li>React Server Components: supporting the native <code>async/await</code> Es7 syntax.</li></ul><h2>The use hook</h2><p>This hook is as controversial as its name. They have chosen this particular name in an attempt to differentiate it from the rest. Why? Because this hook is different: <strong>it can run conditionally</strong>.</p><p>This alone breaks the whole conception of hooks that we have learned over the past years. It is quite remarkable how the React team has baked that idea into our heads. There even was a famous post from Dan Abramov explaining why in detail (<a href=\"https://overreacted.io/why-do-hooks-rely-on-call-order/\">link here</a>).</p><p>How can the <code>use</code> hook be conditionally invoked? Because simplified, it just throws a <code>Promise</code> that is caught by the nearest <code>Suspense</code> parent.</p><figure></figure><p>What is the caveat of this approach? Unlike <code>async/await</code>, the React Component will not resume where it left off. Instead, the suspended component will be re-rendered. This is a side-effect of React components being idempotent, how ironic.</p><p>Let\u2019s an example of the new <code>use</code> hook in action:</p><figure></figure><p>The above code looks simple and easy to reason about. There is only one catch. The <code>&lt;Test /&gt;</code> component will re-render endlessly.</p><p>Why? As seen previously, the rendered is \u201cpaused\u201d by throwing a promise-like exception. The whole component will be re-rendered when the promise is resolved. That means, that the <code>fetchData</code> method will be invoked again which will result in another re-render and so on.</p><p>What are the possible fixes?</p><ul><li>create a cache mechanism for the resolved promises.</li><li>wait and use the <code>cache</code> API that the React team is working on. The ergonomics will be something like <code>use(cache(fetchData))</code> adding more complexity to the mix.</li></ul><p>The <code>cache</code> API has yet to see a draft. The feature would be landing most likely after the", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "b9b64d9a-ec67-4eb9-95ad-344e148821f5": {"__data__": {"id_": "b9b64d9a-ec67-4eb9-95ad-344e148821f5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5ebf8bf6-9020-44f6-879b-a4c6c8c7c931", "node_type": null, "metadata": {}, "hash": "e7cd603ff5dcad820382963c204fdeee8904885ed676765f8a9e6c64648714df"}}, "hash": "e7cd603ff5dcad820382963c204fdeee8904885ed676765f8a9e6c64648714df", "text": "Robin Hossain \u2013 Medium<div><div><a href=\"/@RobinHossain?source=---two_column_layout_sidebar----------------------------------\"><div><p></p></div></a><div><p><a href=\"/@RobinHossain/followers?source=---two_column_layout_sidebar----------------------------------\">73 Followers</a></p></div><p>I am a passionate web programmer, having 9+ years of working experience in Web Development. My best strength is to learn new things very quickly.</p><div><p>Following</p><ul><li><a href=\"/@johnrampton?source=blogrolls_sidebar---two_column_layout_sidebar----------------------------------\"><div><div><p></p></div><p>John Rampton</p></div></a></li><li><a href=\"/@intel?source=blogrolls_sidebar---two_column_layout_sidebar----------------------------------\"><div><div><p></p></div><p>Intel</p></div></a></li><li><a href=\"/@opuhasnat?source=blogrolls_sidebar---two_column_layout_sidebar----------------------------------\"><div><div><p></p></div><p>Opu Hasnat</p></div></a></li><li><a href=\"/@wilw?source=blogrolls_sidebar---two_column_layout_sidebar----------------------------------\"><div><div><p></p></div><p>Wil Wheaton</p></div></a></li><li><a href=\"/@shiningsunny?source=blogrolls_sidebar---two_column_layout_sidebar----------------------------------\"><div><div><p></p></div><p>Shining Sunny</p></div></a></li></ul></div></div>", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "ab7e2450-8880-4ff4-ac81-11e6c8cd9ef7": {"__data__": {"id_": "ab7e2450-8880-4ff4-ac81-11e6c8cd9ef7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c0febe2b-4398-4228-ac1c-5b1b22605cd1", "node_type": null, "metadata": {}, "hash": "d0de34754a6357447aff3fc534b1cba796976ef58d29bb49ea7b450d8fd661e7"}}, "hash": "d0de34754a6357447aff3fc534b1cba796976ef58d29bb49ea7b450d8fd661e7", "text": "Frontend Performance Optimization with Code Splitting using React Lazy & Suspense \ud83d\udd25<div><div><p></p><h2>Frontend Performance Optimization with Code Splitting using React.Lazy &amp; Suspense \ud83d\udd25</h2><p></p><figure></figure><p>Frontend performance is important. JavaScript, though written to be a simple language, can produce surprisingly complex code bases making it difficult to scale up. Part of the reason is that there is a wide variety of classes and modules available. Most substantial JavaScript programs and frameworks have many dependencies, which can make a seemingly simple project embed a large amount of code quickly.</p><p>The more code a project has, the slower the browser will load. Therefore, you often have to balance the size of your dependencies with the performance you expect out of your JavaScript. Code splitting is a useful way to strike this balance.</p><h2>What is code splitting?</h2><figure><figcaption>Client Side Rendering (CSR)</figcaption></figure><p>Many JavaScript frameworks <a href=\"https://reactjs.org/docs/code-splitting.html\">bundle all dependencies</a> into one single large file. This makes it easy to add your JavaScript to an HTML web page. The bundle requires only one link tag with fewer calls needed to set up the page since all the JavaScript is in one place. In theory, bundling JavaScript in this manner should speed up page loads and lower the amount of traffic that page needs to handle.</p><p>At a certain point, however, a bundle grows to a certain size at which the overhead of interpreting and executing the code slows the page load down instead of speeding it up. This critical point is different for every page, and you should test your pages to figure out where this is. There isn\u2019t a general guideline \u2014 it all relies on the dependencies which is being loaded.</p><figure><figcaption>Photo : Crystallize.com</figcaption></figure><p>The key to code splitting is figuring out which parts of a page need to use different JavaScript dependencies. Code splitting allows you to strategically remove certain dependencies from bundles, then insert them only where they are needed. Instead of sending all the JavaScript that makes up the application as soon as the first page is loaded, splitting the JavaScript into multiple chunks improves page performance by a huge margin.</p><p>Code splitting is a common practice in large React applications, and the increase in speed it provides can determine whether a user continues using a web application or leaves. <a href=\"https://www.hobo-web.co.uk/your-website-design-should-load-in-4-seconds/\">Many studies</a> have shown that pages have less than three seconds to make an impression with users, so saving off even fractions of a second could be significant. Therefore, aiming for three seconds or less of load time is ideal.</p><h2>Split and Reduce your Bundles</h2><p>Get rid of anything that takes up too much space. See if there are more lightweight alternatives for the libraries you are using. Using moment.js ? Try out <a href=\"https://date-fns.org/\">date-fns</a>. Using <a href=\"https://lodash.com/\">lodash</a>? Try out <a href=\"https://www.npmjs.com/package/lodash-es\">lodash-es</a>. Make sure you import only the individual parts that you actually use:</p><p>\u2705 <strong>Do \u2026</strong></p><p>import find from \u2018lodash/find\u2019; find([])</p><p><strong>\u274c Don\u2019t \u2026</strong></p><p>import _ from \u2018lodash\u2019; _.find([])</p><figure><figcaption>Photo : Crystallize.com</figcaption></figure><h2>How does code splitting work in React?</h2><p>Different bundlers work in different ways, but React has multiple methods to customize bundling regardless of the bundler used.</p><h2>Dynamic imports</h2><p>Perhaps the simplest way to split code in React is with the dynamic \u201cimport\u201d syntax. Some bundlers can parse dynamic import statements natively, while others require some configuration. The dynamic import syntax works for both static site generation and server-side rendering.</", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "48aa1494-434e-4a93-90ce-5cc22e36b23e": {"__data__": {"id_": "48aa1494-434e-4a93-90ce-5cc22e36b23e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bd097c64-5d9b-4a18-96bb-6e7a277f6bb1", "node_type": null, "metadata": {}, "hash": "1895c14815f99a2762c5251bb4cfdd51e920541298398aa26ca00a2ea4e47214"}}, "hash": "1895c14815f99a2762c5251bb4cfdd51e920541298398aa26ca00a2ea4e47214", "text": "React Lazy, Suspense and Code Splitting<div><div><figure></figure><p>\u2192 Before deployment, React JS is bundled into a <strong>single file</strong> and deployed.</p><p>\u2192 Bundling is great, but as your <strong>app grows,</strong> your <strong>bundle will grow too</strong>. Especially if you are including large third-party libraries. You need to keep an eye on the code you are including in your bundle so that you don\u2019t accidentally make it so large that your app takes a long time to load.</p><p>\u2192 When we are having an application, its bundle file keeps on growing. Instead of making a 25 MB file we can split it and divide the bundle size.</p><p>\u2192 To <strong>avoid winding up with a large bundle</strong>, it\u2019s good to get ahead of the problem and start \u201c<strong>splitting\u201d your bundle</strong>. <strong>Code-Splitting is a feature</strong> supported by bundlers like <a href=\"https://webpack.js.org/guides/code-splitting/\">Webpack</a>, <a href=\"https://rollupjs.org/guide/en/#code-splitting\">Rollup</a> and Browserify (via <a href=\"https://github.com/browserify/factor-bundle\">factor-bundle</a>) which can create multiple bundles that can be <strong>dynamically loaded</strong> at runtime.</p><p>\u2192 Code-splitting your app can help you \u201c<strong>lazy-load</strong>\u201d just the things that are currently needed by the user, which can dramatically improve the performance of your app. While you <strong>haven\u2019t reduced the overall amount of code</strong> in your app, you\u2019ve avoided loading code that the user may never need, and reduced the amount of code needed during the initial load.</p><p>\u2192 The way we can <strong>import synchronous modules.</strong></p><pre>import Foo from './Foo'; // this is for synchronous, declarative,<br /> // webpack finds it and ready it line by line</pre><p>\u2192 The way we can <strong>load asynchronous modules</strong>. It comes with the concept of <strong>dynamic loading.</strong></p><pre>import('./Foo').<strong>then</strong>(Foo =&gt;<br /> console.<strong>log</strong>(Foo)<br />)</pre><p>\u2192 In the application you must have used some concepts, whenever some data is fetched from API, meanwhile we have used loaders and goes away when data is fetched successfully. Easier way is using <strong>React-loadable</strong></p><p>Example:</p><p>Cast.js (Component 1)</p><figure></figure><p>Description.js (Component 2)</p><figure></figure><p>App.js (Regular Way) \u2014 Main Component</p><figure><figcaption>App.js</figcaption></figure><p>O/P:</p><figure></figure><p><strong>App.js (With Lazy Load) \u2014 Main Component</strong></p><p>\u2192 Lazy load is the <strong>optimization trick.</strong></p><p>\u2192 Convert regular import into asynchronous import</p><pre>var Cast = <strong>React</strong>.<strong>lazy</strong>(() =&gt; import('./Cast'));// import Cast from './Cast'; // Regular</pre><p>\u2192 So the component which will import late should be added in &lt;Suspense&gt;. Inside Suspense Component we keep all the asynchronous components that are <strong>dynamic import.</strong></p><p>eg. purposely for the demo <strong>we delayed two components</strong> \u2014 500 milliseconds and 1000 milliseconds. So it will load all in 1000 milliseconds</p><p>\u2192 The <strong>React.lazy</strong> function lets you render a dynamic import as a regular component.</p><p>App.js (With lazyload)</p><figure></figure><p><strong>Conclusion:</strong></p><ol><li>Use <strong>asynchronous imports</strong> on those components which will take time to load. eg. images", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "01e2dc84-a538-4b8e-8a3e-0545254b5237": {"__data__": {"id_": "01e2dc84-a538-4b8e-8a3e-0545254b5237", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "b415e45a-18ae-49cd-8c7e-084a1782fb49", "node_type": null, "metadata": {}, "hash": "b3f68110625750f0213aca10b47f881b5b09ea378ca58d690b4541c0d731fb05"}}, "hash": "b3f68110625750f0213aca10b47f881b5b09ea378ca58d690b4541c0d731fb05", "text": "React Suspense and Error Boundary<div><section>\n <p></p>\n<p>TLDR: Suspend can catch Promise from children and render fallback until the promise is resolved.</p>\n<p>In React 16.6, React is adding the <code>Suspense</code> component that it can render fallback while the app is loading javascript or fetching API. You can see the demonstration from Dan Abramov\u2019s <a href=\"https://www.youtube.com/watch?v=nLF0n9SACd4\">presentation</a> in React conf.</p>\n<p>From the <a href=\"https://reactjs.org/docs/concurrent-mode-suspense.html\">documentation</a> on Reactjs webside, the example below:</p>\n<p>Can render \u201cLoading profile\u2026\u201d while <code>ProfileDetails</code> is loading, and \u201cLoading posts\u2026\u201d while <code>ProfileTimeline</code> is loading. It can control the timing of render components, skip the children while loading, and avoid race conditions in children. However, it doesn\u2019t just work like magic as the document described. Because for the Suspense component to work, the API needs to follow certain criteria.</p>\n<p>How Suspense work is similar to the ErrorBoundary in React, for example:</p>\n<p>Can catch any errors thrown in the children and skip the render in children. Suspense is similar to ErrorBoundary, But instead of catching the error, it is catching Promise that is thrown from the children, render fallback while the promise is pending, and unblock the children when the promise is resolved.</p>\n<p>To understand how it works, we can take a look at the source code of <a href=\"https://github.com/facebook/react/blob/master/packages/react/src/ReactLazy.js\"><code>React.Lazy</code></a>, <code>React.Lazy</code> can work with Suspense, wrapping javascript <code>import</code> and trigger Suspense fallback while loading the component:</p>\n<p>A simplified version of <code>React.lazy</code> source code looks like this:</p>\n<p>Therefore for Suspense to work, the API needs to:</p>\n<ol>\n<li>Trigger <code>Promise</code> that loads the data</li>\n<li>Throw the <code>Promise</code> while loading</li>\n<li>Cache the result and return the result when the <code>Promise</code> is resolved.</li>\n</ol>\n<h2><a href=\"#Data-Fetching\"></a>Data Fetching</h2><p>Let\u2019s try to implement data fetching to support Suspense. We can reuse the concept in <code>React.lazy</code> and replace the <code>import</code> with <code>fetch</code> </p>\n<p>With the <code>suspenseFetch</code> function above, we can convert fetch into a suspense compatible API.</p>\n<p><a href=\"https://github.com/andreiduca/use-async-resource\">use-async-resource</a> is a package that can turns fetch into suspense compatible API too, with support for params and fetching the new result. It is a good resource if you want to implement the API with Suspense.</p>\n<h2><a href=\"#Conclusion\"></a>Conclusion</h2><p>Suspense is an interesting concept that makes errors and async handling declarative, and it is supported on React level so it will be more stable and easy to handle in the future. However, the Apollo graphql client will not support Suspense API due to the usage of <code>useRef</code> does not support throwing promises and errors. But we will see more libraries in React world support Suspense in the future.</p>\n<h2><a href=\"#Reference\"></a>Reference</h2><ul>\n<li><a href=\"https://itnext.io/what-the-heck-is-this-in-react-suspense-c5e641e487a\">https://itnext.io/what-the-heck-is-this-in", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "316d24eb-6214-4da2-8a37-00e4b83227e8": {"__data__": {"id_": "316d24eb-6214-4da2-8a37-00e4b83227e8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9a8cadb3-8c39-45e8-8361-ae7fc4f77539", "node_type": null, "metadata": {}, "hash": "0f289da5f37a8f537f2aa30ba36e18f9ca7496065d938140570e87d14464b6c4"}}, "hash": "0f289da5f37a8f537f2aa30ba36e18f9ca7496065d938140570e87d14464b6c4", "text": "Let\u2019s build a React from scratch: Part 3\u2014 React Suspense and Concurrent Mode<div><div><blockquote><p><strong>Disclaimer</strong>: The content below is just for learning and have some key insights while using framework like React. While the inspiration is React, the idea is to deliver the core concepts of what it takes to build a library like React at its most basic level.</p></blockquote><p>Hello there! Welcome to the 3rd Part of this Series, which talks about Performance a bit while using libraries like React. What are the traditional bottlenecks for large applications and how React is planning on solving them by introducing <strong>React Suspense</strong> and <strong>Concurrent Mode?</strong> To be honest, I didn\u2019t plan the timeline but it so turned out that <strong>React 18</strong> which packs all these awesome features just got released <strong>yesterday</strong> for general usage.</p><figure></figure><p>So, it will be an <strong>amazing time to talk about them and have a deep understanding </strong>of how <strong>these actually work</strong>. The bottom line, it can make your app really fast and predictable even with slow computing or slow network connections.</p><p><strong>Concurrent rendering</strong> also <strong>unveils the door for progressive server-side rendering </strong>as well. Now all of these might seem alien to you (at least, it was to me), so as always <strong><em>we will start from the basics and build our way up to all these by implementing them</em></strong>. This time, there will be a little bit of theory before hands-on coding, but the concepts will go a long way in helping us build what we are aiming for. So, let\u2019s get started...</p><ul><li><a href=\"/lets-build-a-react-from-scratch-part-1-virtualdom-and-renderer-14f4f716de62\">Part 1 \u2014 VirtualDOM and React renderer</a></li><li><a href=\"/lets-build-a-react-from-scratch-part-2-state-management-and-react-hooks-e771c5c06066\">Part 2 \u2014 State Management and React Hooks</a></li><li><strong>Part 3 \u2014 React Suspense and Concurrent Mode</strong></li><li><a href=\"/lets-build-a-react-from-scratch-part-4-server-side-rendering-and-its-challenges-b7b87c84bbf\">Part 4 \u2014 Server Side Rendering and its Challenges</a></li></ul><h2>\ud83e\udd81 React Rendering Techniques \ud83d\udc12</h2><p>In the first section, we talked about how we take a VirtualDOM and render it out to the Browser. But sometimes(most of the time :)), <strong>you have to fetch the data from some remote API </strong>before you <strong>can use that to render it to the DOM</strong>. Now, in general, in react for these there are <strong>three primitive rendering techniques, let\u2019s discuss them briefly here</strong>,</p><h2>Approach 1: Fetch-on-Render (not using Suspense)</h2><p>The first, and most traditional approach would be to manage<strong> the fetching after the initial render and when the data is ready</strong>, we populate the same using <strong>our States in React</strong>. Let\u2019s see a quick example,</p><pre>function ProfilePage() {<br /> const [user, setUser] = useState(null);<strong><em>useEffect(() =&gt; {<br /> fetchUser().then(u =&gt; setUser(u));<br /> }, []);</em></strong>if (user === null) {<br /> return &lt;p&gt;Loading profile...&lt;/p&gt;;<br /> }<br /> return (<br /> &lt;&gt;<br /> &lt;h1&gt;{user.name}&lt;/h1&gt;<", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "ed0c8f42-61f7-4f9b-91ca-dc4ed3e8a335": {"__data__": {"id_": "ed0c8f42-61f7-4f9b-91ca-dc4ed3e8a335", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "17e4b40b-36a3-4fbf-bd6c-187c30472a3b", "node_type": null, "metadata": {}, "hash": "5935e48b690c3fb01b291023c72677c5e1ca4964fc4c3608a356e52183097c94"}}, "hash": "5935e48b690c3fb01b291023c72677c5e1ca4964fc4c3608a356e52183097c94", "text": "Introduction to React v18 Suspense and Render-as-You-Fetch approach<div><div><h2>React v18 features: Suspense</h2><p></p><h2>In this lesson, we are going to explore React\u2019s new \u201dSuspense\u201d API released in v18 and how concurrent features work.</h2><p></p><figure><figcaption>(source: <a href=\"https://unsplash.com/photos/jf1EomjlQi0\"><strong>unsplash.com</strong></a>)</figcaption></figure><p>Loading data has always been a hassle in web development, whether you are working with React or any other framework. The problem arises when you have multiple API calls to fetch data and you need to show the user the loading state of the application. Let\u2019s take a small example.</p><figure><figcaption>(source: <a href=\"https://codesandbox.io/s/react-suspense-normal-fetch-parallel-5kiiuh\">https://codesandbox.io/s/react-suspense-normal-fetch-parallel-5kiiuh</a>)</figcaption></figure><p>In the example above, we have a small application in which we display the User and Post data by making external Rest API calls individually from the components responsible to display them which are <code>User</code> and <code>Post</code>.</p><p>We have added a manual delay in the API response but in the real world, this can be a pretty usual behavior. The <code>/users/</code> call resolves in <code>5s</code> while <code>/posts/</code> call resolves in <code>3s</code>, a little earlier than the <code>/users</code> call. Until the request resolves, they display a <code>Loading...</code> message on the screen.</p><p>Since these requests run in parallel, you can\u2019t really guess which one will resolve first. In our case, we see <code>Post</code> earlier than the <code>User</code> and perhaps that would not be a very good experience. If we have a complex application with multiple parallel requests, we would see different parts of the application load in random order. The more natural behavior for an application is to render things from top to bottom.</p><p>To fix this issue, we can use a <strong>waterfall</strong> pattern. What we could do is to nest the <code>Post</code> component inside <code>User</code> such that <code>Post</code> only appears when <code>User</code> is finished loading its data. It would look like the below.</p><figure><figcaption>(source: <a href=\"https://codesandbox.io/s/react-suspense-normal-fetch-waterfall-vyswny\">https://codesandbox.io/s/react-suspense-normal-fetch-waterfall-vyswny</a>)</figcaption></figure><p>The only thing we modified above is the position of the <code>Post</code> component where it renders. Instead of it being rendered inside the <code>App</code> component, now it renders inside the <code>User</code> component, once the <code>/users/</code> API call is resolved.</p><p>But now we can see another issue. The <code>Post</code> component doesn\u2019t start fetching its data until <code>/users/</code> API call is resolved. This is by design but now the total loading time of the application is <code>3s + 5s</code>. This is one of the problems with waterfall data fetching patterns apart from the obvious complexity of the code it introduces.</p><p>In both cases, we have something to lose and these problems could have been easily solved if the <code>App</code> component could have managed the orchestration of its children. Well, that can be managed if <code>App</code> component itself fetches the data for <code>User</code> and <code>Post</code> component and decide when to render them.</p><figure><figcaption>(source: <a href=\"https://codesandbox.io/s/react-suspense", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "45ed8b2d-f078-4803-ab8f-56862cc194b0": {"__data__": {"id_": "45ed8b2d-f078-4803-ab8f-56862cc194b0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "e353ca95-83c9-4941-acf7-2839c51a7743", "node_type": null, "metadata": {}, "hash": "2df204576fa377b8e254c57195854dfc9cee09b82133cf73764316fa97599f23"}}, "hash": "2df204576fa377b8e254c57195854dfc9cee09b82133cf73764316fa97599f23", "text": "React 18 Suspense Minimal Example<div><div><figure></figure><p>In the current version of React (<code>17.0.2</code> at the day of this article creation), <code>Suspense</code> is a component, that allows developers to lazy-load application parts. It accepts <code>fallback</code> property, with content to display, while the child component is lazy-loading.</p><figure></figure><p>However, starting with React 18 it will be possible to use <code>Suspense</code> for data fetching. This means, that <code>fallback</code> will be displayed until the component will fetch all the data needed. Or in general, all events that components expect will occur. Let's say we want to just display the placeholder for 2 seconds:</p><figure></figure><p>As you could guess, <code>Loading...</code> will be displayed for 2 seconds and <code>Component loaded</code> afterward.</p><p>However, when I first saw the code above, I didn't understand <em>HOW</em> did that happen... What is that magic mechanism in the <code>useTimeout</code> hook? In short, it has to:</p><ol><li>Stop component code execution.</li><li>Let <code>Suspense</code> know that the component isn't yet ready</li><li>Notify <code>Suspence</code> when it should re-attempt with rendering component.</li></ol><p>To stop code execution you need to use the <code>throw</code> statement. In order to make <code>Suspense</code> know it's expected, the value thrown need to be a <code>Promise</code>. <code>Suspense</code> will catch this promise and subscribe to it, to re-attempt rendering.<br />Please note: the code below is just for a demo purpose:</p><figure></figure><p><em>(Confused about </em><code><em>||=</em></code><em> ? Check </em><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR_assignment\"><em>this doc</em></a><em>)</em></p><p>It turns out that suspense uses quite simple mechanisms, but there\u2019s a hard part. You might ask why <code>fullfilled</code> and <code>promise</code> couldn't be stored in a ref, so the hook would be reusable:</p><figure></figure><p>It turns out, that while the component is not loaded, hooks can\u2019t be really used. The component will be unmounted/mounted on every render attempt before the render will complete without throwing promises. Hence to figure out, if this component has actually started the data loading process, we should rely on a globally available cache. (In our simplified case it\u2019s just <code>fullfilled</code> variable). Of course, in a real-world example such a simple approach wouldn't work (this hook works only one time).</p><p>This is why it\u2019s advised to use good libraries that support suspense (like <a href=\"https://swr.vercel.app/\">SWR</a>).</p><p><a href=\"https://codesandbox.io/s/suspense-timeout-example-4g7rh\">Full code</a> of the example above.</p><p>\ud83d\udc4b</p><p><em>More content at </em><a href=\"http://plainenglish.io/\"><strong><em>plainenglish.io</em></strong></a><em>. Sign up for our </em><a href=\"http://newsletter.plainenglish.io/\"><strong><em>free weekly newsletter</em></strong></a><em>. Get exclusive access to writing opportunities and advice in our </em><a href=\"https://discord.gg/GtDtUAvyhW\"><strong><em>community Discord</em></strong></a><em>.</em></p></div>", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "b5329123-7c2c-4ccb-bbfd-c9ddf9c9d8a1": {"__data__": {"id_": "b5329123-7c2c-4ccb-bbfd-c9ddf9c9d8a1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "353a5383-fb34-47a7-8a88-847b2bacf0bc", "node_type": null, "metadata": {}, "hash": "ec9ed7f27060743a9f3eed7d2ffe7429edceec8ff2f50749ce3c419d6c679421"}}, "hash": "ec9ed7f27060743a9f3eed7d2ffe7429edceec8ff2f50749ce3c419d6c679421", "text": "Data fetching with Suspense in React<div><section>\n <p>Suspense allows us to suspend component rendering. Suspense in React is not a library or server state manager; it\u00e2\u0080\u0099s literally what the word Suspense entails, a feature for managing asynchronous operations in a React app, keeping things in suspense until data are ready.</p>\n<p>In this article, we will look at how Suspense works by fetching data from an API and rendering it in our application. In the course of this article, we will use <a href=\"https://jsonplaceholder.typicode.com/\">Jsonplaceholder</a> for our API.</p>\n<h2>Why Suspense?</h2>\n<p>Suspense aims to help with handling async operations by letting you wait for a code to load. It\u00e2\u0080\u0099s needed because users need their eyes fed with something like a spinner, so they know they expect data to be displayed. Concisely, Suspense will defer the execution of a component\u00e2\u0080\u0099s tree until the Promise is either resolved or rejected. Sites without proper handling of asynchronous operations are considered wretched sites.</p>\n<p>How do we fetch data without Suspense? The following code is typical:</p>\n<pre><code>const [lyrics, isLoading] = fetchData(\"/lyrics\");\nif (isLoading) {\n return &lt;Spinner /&gt;;\n}\nreturn &lt;Lyrics data={lyrics} /&gt;;</code></pre>\n<p>A variable <code>isLoading</code> is used to track the <code>status</code> of the request. If it\u00e2\u0080\u0099s true, we render a <code>spinner</code>. The spinner is used for a better user interface, enabling the user to know that data is being fetched. There\u00e2\u0080\u0099s absolutely nothing wrong if we do it this way, but there are better ways of getting this done. Let\u00e2\u0080\u0099s see the simplest use case of Suspense:</p>\n<pre><code>const lyrics = fetchData(\"/lyrics\");\nreturn (\n &lt;Suspense fallback={&lt;Spinner /&gt;}&gt;\n &lt;Lyrics data={lyrics} /&gt;\n &lt;/Suspense&gt;\n);</code></pre>\n<p>These are the changes that Suspense brought to the way we handle network calls:</p>\n<ul>\n<li>Instead of doing it by hand, we have Suspense rendering a fallback (spinner) declaratively.</li>\n<li>React didn\u00e2\u0080\u0099t know there was a network call, so we had to manage the loading state by ourselves. Using Suspense, React identifies that a network call is made and running.</li>\n<li>By wrapping the Lyrics component with Suspense, it suspends rendering data until the network call is done.</li>\n</ul>\n<p>How does React know that a network call was made and is pending, is React that smart? Suspense renders a fallback component, but in no place in the code do we communicate to React that we are making a network request. This is where data fetching libraries such as Axios come into play. For the benefit of this tutorial, we will use Axios to communicate the loading state to React.</p>\n<h2>Data fetching using Suspense</h2>\n<p>Create a folder, head into your text editor, open your terminal and run the below commands;</p>\n<pre><code>npx create-react-app suspense\ncd suspense \nnpm install react@rc react-dom@rc --save //we need to manually do it this way because Suspense is not yet stable. \nnpm install axios --save\nnpm start</code></pre>\n<p>To handle data fetching, we will need a folder; I named mine <code>FetchApi</code>. This folder will have two files: <code>Fetch.js</code> and <code>WrapPromise.js</code>. These files will be responsible for fetching data from our API and communicating to Suspense. We will discuss more on this as we progress in the article for a better understanding.</p>\n<h3>Fetch.Js</h3>\n<p>We will use <a", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "46df02a2-3955-4c1d-878b-b4cd7a23e0dd": {"__data__": {"id_": "46df02a2-3955-4c1d-878b-b4cd7a23e0dd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "7dff9daf-6ab4-4a16-ae04-f62216c42514", "node_type": null, "metadata": {}, "hash": "a1551bc435b8ed2cad277cb166894f436248dcca4b1de18450fb64456af56f5e"}}, "hash": "a1551bc435b8ed2cad277cb166894f436248dcca4b1de18450fb64456af56f5e", "text": "How to Improve Data Fetching in React With Suspense?<div><div><article><div><p></p><h2>Looking at experimental features of React</h2><p></p><figure><figcaption>Photo by <a href=\"https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral\">Ferenc Almasi</a> on <a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><p>When dealing with components in React, we often find ourselves introducing additional logic to handle different states based on the availability of data. With the introduction of <code><a href=\"https://reactjs.org/docs/concurrent-mode-suspense.html\">&lt;Suspense&gt;</a></code> from React 16.6, this extra logic may not be needed anymore.</p></div></article></div>", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "595efc0e-9f6f-4445-959e-e8c9ac32fbbd": {"__data__": {"id_": "595efc0e-9f6f-4445-959e-e8c9ac32fbbd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "3997a495-20e0-4c1f-a940-e55e3ef3a1b2", "node_type": null, "metadata": {}, "hash": "2f6bab0f0d6c5cd8ac3d4df9cab58d32ff9f88c7e823c36fb10c482e8bebd532"}}, "hash": "2f6bab0f0d6c5cd8ac3d4df9cab58d32ff9f88c7e823c36fb10c482e8bebd532", "text": "Using React Suspense for Better Server-Side Rendering<div><div><p></p><h2>Improve user experience and performance in server-side rendering with React suspense</h2><p></p><figure></figure><p>Server-side rendering is increasingly becoming popular among web developers. However, implementing server-side rendering in React applications did not meet the expectations and caused a lousy developer and user experience.</p><p>As a result, React included React Suspense in their upcoming React 18 release to improve the performance of server-side rendering in React applications.</p><p>This article will discuss what React Suspense is and how developers can take advantage of it to improve their React applications.</p><h2><strong>Introduction to React Suspense</strong></h2><p>React Suspense is a React component that pauses (suspends) an element\u2019s rendering unless all the data it requires is available. It assures that data is ready before rendering components and helps avoid loading components with pending data.</p><p>Your child component should implement lazy loading via <code>React.Lazy</code> to use React Suspense. You can even specify multiple lazy loading components with a single <code>Suspense</code> component as well.</p><pre>import React from \"react\"<br />import Spinner from \"components/Spinner\"<p>const SomeComponent = React.lazy(() =&gt; import('components/SomeComponent'));</p><p>export default function App(){<br /> return (<br /> &lt;React.Suspense fallback={&lt;Spinner /&gt;}&gt;<br /> &lt;SomeComponent /&gt;<br /> &lt;/React.Suspense&gt;<br /> )<br />}</p></pre><p>As shown above, all you have to do is wrap the component tree with the <code>Suspense</code> component specifying a fallback UI. React then will prioritize rendering based on the availability of the child React components. If some elements are not yet ready, <code>Suspense</code> will continue to show a fallback UI in place of those React components until they are ready.</p><h2><strong>A Primer on Server-side Rendering</strong></h2><p>Server-side rendering is a technique where React components are compiled into HTML server-side and sent to clients. So, end-users will not have to wait till the client-side JavaScript is executed and the application is rendered.</p><p>Server-side rendering is increasingly becoming popular because it solves some major problems with client-side rendering. When a single page application is rendered on the client-side, the user sees a blank screen until JavaScript is executed and the UI is rendered. The larger the size of the application is, the longer the time it takes to render, causing a bad user experience. Also, search engines can only access JavaScript bundles in client-side rendering. Therefore, they cannot crawl and index the web app, which negatively affects the SEO performance.</p><p>In the current method of server-side rendering, the app fetches all data required for the entire application. After data is received, the whole application is compiled to HTML on the server, using the <code>renderToString</code> method. The produced markup is then sent in the response. Finally, the JavaScript is loaded for the entire application on the client-side and connected to the generated HTML.</p><pre>import React from 'react';<br />import { renderToString } from 'react-dom/server';<br />import App from './components/app';<br />module.exports = function render(initialState) {<br /> let content = renderToString(&lt;App /&gt;);<br /> return content<br />};</pre><h2><strong>Challenges in Server-side rendering in React</strong></h2><p>Server-side rendering in React indeed brings many advantages, but it is not a silver bullet. In the current way of implementing server-side rendering, the whole React application is compiled to HTML and then sent to the client. That is, the application should have all data fetched beforehand.</p><p>This process will not cause issues in small projects", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "1d150695-1c81-4b6c-94ea-ea2f4c14b745": {"__data__": {"id_": "1d150695-1c81-4b6c-94ea-ea2f4c14b745", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "93247a89-3d19-498c-b935-a0d1a8bf16ef", "node_type": null, "metadata": {}, "hash": "ee87438ac6fe3073b7acd65837b53c41a70a703e9dc1e3c83b4b47fffceaf8ec"}}, "hash": "ee87438ac6fe3073b7acd65837b53c41a70a703e9dc1e3c83b4b47fffceaf8ec", "text": "Code Splitting React Router Routes with React Lazy and React Suspense<div><div><figure></figure><p>Recently I\u2019ve got back to creating side projects, which is actually quite refreshing, albeit, with all the technology options, it can be quite time-consuming and daunting to just get started. Anyhow, as I\u2019ve been working on my own side project (I will post it to YouTube at some point), I\u2019ve become much more interested in performance, and as I was optimising my application (which I do after, although if I can get some quick wins along the way, great) I thought the first easy win was to just decrease the bundle size.</p><p>So how do we go about decreasing the bundle size? Well, the first quick win, if you\u2019re using client-side rendering that is, and of course React Router (this does not work with SSR), is to simply split your routes \u2014 basically get rid of anything that isn\u2019t directly used on the page the user is visiting.</p><h2>Here\u2019s an example\u2026</h2><p>A user visits your homepage and let\u2019s say the user downloads your initial bundle which isn\u2019t cached at around 320kb, well what is in that bundle for it to be 320kb? Turns out you have 5 additional 5 routes in there (that aren\u2019t being directly used)\u2026so what do we do with those additional 5-page routes that aren\u2019t currently being used on the homepage? The answer is simple, we get rid of them! \ud83d\uddd1\ufe0f</p><h2>Karl, but what exactly is code splitting?</h2><p>Code splitting is basically the removal of code that the user does not need right now. Prime example\u2026 the user visits your website, and the browser downloads the JavaScipt bundle file which includes:</p><p><code>Home, sign in, sign up, faqs, docs</code></p><p>It\u2019s clear that we don\u2019t need <code>sign in, sign up, faqs, docs</code> right now, so we can just remove them from the initial bundle, lowering our bundle size!</p><p>Lowering our bundle size is great because it means our website will load faster and if you\u2019re not caching the JS file downloads, you\u2019re probably saving your users from having to pay extra for data if they\u2019re on mobile!</p><p><strong>Only ship the minimal amount of code to the browser to render the page the user is on!</strong></p><h2>Okay, that\u2019s fine, but how do we do that?</h2><p>Enter dynamic routes, React Suspense and React lazy!</p><p>Let\u2019s say you have a basic React router setup like so:</p><pre>&lt;Router&gt;<br /> &lt;Switch&gt;<br /> &lt;Route path=\"/sign-in\"&gt;<br /> &lt;SignIn /&gt;<br /> &lt;/Route&gt;<br /> &lt;Route path=\"/sign-up\"&gt;<br /> &lt;SignUp /&gt;<br /> &lt;/Route&gt;<br /> &lt;Route exact path=\"/\"&gt;<br /> &lt;Home /&gt;<br /> &lt;/Route&gt;<br /> &lt;/Switch&gt;<br />&lt;/Router&gt;</pre><p>This looks normal, right? Well, it is. Unfortunately, if you look in the dev tools and take a look for your bundle file (take a look, I\u2019m sure you\u2019ll be able to find it!), do a search for the contents that are within sign in or sign up. If you have \u2018username\u2019, or \u2018email address\u2019 within the sign in or sign up pages, search for it within your bundle, and you will see it\u2019s in there!</p><p>We don\u2019t want it to be in there because we\u2019re not using it right now!</p><p>Of course, don\u2019t forget your imports:</p><pre>import React from 'react';<br />import { BrowserRouter as Router", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "ec950c06-ba9e-4ba6-ac1c-86921d56d6f1": {"__data__": {"id_": "ec950c06-ba9e-4ba6-ac1c-86921d56d6f1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "35fb1684-4a20-4e7f-a374-eac16b8a42b4", "node_type": null, "metadata": {}, "hash": "c2dc3f7c5682fe018a7a8f524847f1c03af58f041d6cc94367ff5d58094cbecc"}}, "hash": "c2dc3f7c5682fe018a7a8f524847f1c03af58f041d6cc94367ff5d58094cbecc", "text": "React18: What\u2019s new?<div><div><article><div><div><figure></figure><p>There are 3 major API update and all three are going to impress you.</p><ul><li><strong>Transition</strong></li><li><strong>Batching</strong>, Automatic batching for fewer renders</li><li><strong>Suspense</strong>, SSR support for Suspense</li></ul><h2>Transition</h2><p>If you have two states to render two component, which component should get more priority?</p><pre>setChart(chartInput); // let's say it is Urgent updates<br />setTable(tableResult); // let's say it is Transition updates</pre><p>We classify state updates in two categories:</p><ul><li><strong>Urgent updates reflect direct interaction,</strong> like typing, clicking, pressing, and so on.</li><li><strong>Transition updates</strong> transition the UI from one view to another.</li></ul><p><strong>In React 18 version</strong>, use <code>startTransition</code>, now you can control the priority of component. This is great right ?</p><p>React offers a new built-in <code>useTransition()</code> Hook to help with this.</p><p>Our <code>useTransition()</code> call returns two values: <code>startTransition</code> and <code>isPending</code>.</p><pre>const [<strong>startTransition</strong>, <strong>isPending</strong>] = <strong>useTransition</strong>({ timeoutMs: 3000 });</pre><blockquote><p>Wrapping setState in a Transition</p></blockquote><pre>// Priority 1, urgent update<br />setChart(input);<p>// Priority 2, not so urgent update<br /><strong>startTransition</strong>( () =&gt; {<br /> setTable(tableResult);<br />})</p></pre><p>Updates wrapped in <code>startTransition</code> are handled as non-urgent and will be interrupted if more urgent updates like clicks or key presses come in.</p><h2>Where can I use it?</h2><ul><li>You can use <code>startTransition</code> to wrap any update that you want to move to the background.</li></ul><p><strong>These type of updates fall into two categories:</strong></p><ul><li><strong>Slow rendering: </strong>These updates take time because React needs to perform a lot of work in order to transition the UI to show the results.</li><li><strong>Slow network: </strong>These updates take time because React is waiting for some data from the network. This use case is tightly integrated with Suspense.</li></ul></div><div><h2>Batching, <strong>use </strong><code><strong>flushSync()</strong></code></h2><ul><li>Batching is when React groups multiple state updates into a single re-render for better performance. This is great for performance because it avoids unnecessary re-renders.</li><li>or, Batching is the process in which react holds to send a DOM re-render call. They collect a few state update events that are happening in same function call and sends just 1 call to update the DOM.</li><li>We only batched updates during the React event handlers. Updates inside of promises, setTimeout, native event handlers, or any other event were not batched in React by default.</li><li>Example, It will be fired at the end of all state changes.</li></ul><pre>const demoApp = () =&gt; {<br /> const [b1, setButtonOne] = useState('green');<br /> const [b2, setButtonTwo] = useState('Orange');<br /> const [b2, setButtonThree] = useState('pink');<p> const handleClick = () =&gt; {<br /> setButtonOne('white'); //NOT YET<br /> setButtonTwo('white'); // NOT YET<br /> setButtonThree('white')<br /> //Now re render<br /> }</p><p> return(<br /> &lt;&gt;<br /> &lt;", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "50e80d53-dfc3-402b-96f9-6ff0c7420f68": {"__data__": {"id_": "50e80d53-dfc3-402b-96f9-6ff0c7420f68", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "fd92e2aa-987b-42b9-8b0f-7ba363da2ace", "node_type": null, "metadata": {}, "hash": "ec713a31fe45ff1cd47a9f38021a27029ade52d1800ad214f85f70ab5d829769"}}, "hash": "ec713a31fe45ff1cd47a9f38021a27029ade52d1800ad214f85f70ab5d829769", "text": "What\u2019s Concurrent with React 18?<div><div><figure></figure><p>React\u2019s previous update, React 17, shipped with <strong>ZERO</strong> new features and was arguably the most boring version of React in the library\u2019s history \u269b\ufe0f</p><p>At the time people speculated about React\u2019s future, about what this all might mean, going so far as to suggest the library\u2019s best days were behind it.</p><p>Time, however, has given us a new perspective. That the React team are smart mofos playing the long game, reinforcing React\u2019s internals in preparation for React 18 \u2014 A huge update, with no breaking changes!</p><p>Come with me on a journey. Together we\u2019ll explore some of the new features in React 18.</p><h2>Suspense</h2><p>Suspense has been around since React 16 but only as an experimental feature. A stable production-ready version of the suspense API is planned for React 18\u2019s release.</p><figure></figure><h2>What Does Suspense Do?</h2><p><strong>Suspense </strong>is a new way to get components to wait for data.</p><p>At the moment, React can\u2019t help but render components straight away whether it has the data it needs or not.</p><p>As devs, we work around this, using conditionals and effects. Often we create a new piece of state that changes when the data has loaded to trigger a re-render and update the component.</p><p>Suspense is basically some syntactic sugar that handles that whole process for you.</p><pre>&lt;Suspense fallback={&lt;Loading/&gt;}&gt;<br /> &lt;PatientComponent&gt;<br />&lt;/Suspense&gt;</pre><p>Nine times out of ten, a fallback component is just a loading component.</p><figure></figure><figure></figure><p>Once the data is available, React is alerted and replaces the fallback component with what was wrapped in your suspense tags</p><p>All of that from a single</p><p>&lt;Suspense/&gt;</p><p>Another cool thing about suspense is it applies to child components and a child components\u2019 child components.</p><p>The suspense block doesn\u2019t need to be the direct parent of the component that\u2019s waiting for data. If data is missing, React will walk up the tree until it finds a fallback component to render.</p><h2>Why Suspense Is Important for Server-Side Rendering?</h2><p><em>\u201cWhen running React client-side your React App will just show you a blank page while it\u2019s loading.\u201d</em></p><p>SSR (Server Side Rendering) on the other hand is known for its crazy fast initial rendering that gets something pretty in front of the user way sooner.</p><p>This is important \u2014 \u201cAs <strong>page load time</strong> goes from 1 second to 3 seconds, the probability of <strong>bounce</strong> increases 32%\u201d \u2014 <a href=\"https://www.thinkwithgoogle.com/marketing-strategies/app-and-mobile/page-load-time-statistics/#:~:text=The%20probability%20of%20bounce%20increases,Google%2FSOASTA%20Research%2C%202017.\">Google</a>.</p><p>Until recently, I thought this wicked speed was the result of servers being OP, <a href=\"https://medium.com/r?url=https%3A%2F%2Fgithub.com%2Freactwg%2Freact-18%2Fdiscussions%2F37\">but after reading this post from Dan Abramov</a>, I learned how these pages are shown earlier:</p><p><strong>Here are the steps an SSR React application takes to show the user a page.</strong></p><ul><li>On the server, fetch data for the entire app.</li><li>Then, on the server, render the entire app to HTML and send it in the response.</li><li>Then, on the client, load the JavaScript code for the entire app.</li><li>", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}}, "docstore/ref_doc_info": {"e17b0c64-cd9f-41cf-abe9-a67210123a81": {"node_ids": ["8d10acbf-4785-41b5-bb15-29428240f49b"], "metadata": {}}, "0d19f0ac-00ca-448c-873e-bc6a715643d0": {"node_ids": ["387325e3-7ce0-4b20-8fd9-c6c5d590babf"], "metadata": {}}, "2e8d6e17-f630-4efa-a991-18098e483b6e": {"node_ids": ["d985c931-26d8-41db-9d80-f6f92bd6ef31"], "metadata": {}}, "7bcb053a-7806-48d6-8515-e407b7e89107": {"node_ids": ["3cb0172f-8f4e-4022-ab14-e9e007485b0f"], "metadata": {}}, "cd58ec20-3daa-4bdf-ad88-fccae5b01bf6": {"node_ids": ["0244ebf4-5d48-450d-a22d-e83d36ae94e2"], "metadata": {}}, "ec7a2c48-3d51-42b1-93c7-8944c62d987a": {"node_ids": ["203f6855-7fcd-4404-bd51-41087cac207b"], "metadata": {}}, "a4cf75d4-4dd4-4848-ae4b-2eafbfc3825c": {"node_ids": ["fdad0bae-c99d-4711-861c-6b3d2b057c82"], "metadata": {}}, "5ebf8bf6-9020-44f6-879b-a4c6c8c7c931": {"node_ids": ["b9b64d9a-ec67-4eb9-95ad-344e148821f5"], "metadata": {}}, "c0febe2b-4398-4228-ac1c-5b1b22605cd1": {"node_ids": ["ab7e2450-8880-4ff4-ac81-11e6c8cd9ef7"], "metadata": {}}, "bd097c64-5d9b-4a18-96bb-6e7a277f6bb1": {"node_ids": ["48aa1494-434e-4a93-90ce-5cc22e36b23e"], "metadata": {}}, "b415e45a-18ae-49cd-8c7e-084a1782fb49": {"node_ids": ["01e2dc84-a538-4b8e-8a3e-0545254b5237"], "metadata": {}}, "9a8cadb3-8c39-45e8-8361-ae7fc4f77539": {"node_ids": ["316d24eb-6214-4da2-8a37-00e4b83227e8"], "metadata": {}}, "17e4b40b-36a3-4fbf-bd6c-187c30472a3b": {"node_ids": ["ed0c8f42-61f7-4f9b-91ca-dc4ed3e8a335"], "metadata": {}}, "e353ca95-83c9-4941-acf7-2839c51a7743": {"node_ids": ["45ed8b2d-f078-4803-ab8f-56862cc194b0"], "metadata": {}}, "353a5383-fb34-47a7-8a88-847b2bacf0bc": {"node_ids": ["b5329123-7c2c-4ccb-bbfd-c9ddf9c9d8a1"], "metadata": {}}, "7dff9daf-6ab4-4a16-ae04-f62216c42514": {"node_ids": ["46df02a2-3955-4c1d-878b-b4cd7a23e0dd"], "metadata": {}}, "3997a495-20e0-4c1f-a940-e55e3ef3a1b2": {"node_ids": ["595efc0e-9f6f-4445-959e-e8c9ac32fbbd"], "metadata": {}}, "93247a89-3d19-498c-b935-a0d1a8bf16ef": {"node_ids": ["1d150695-1c81-4b6c-94ea-ea2f4c14b745"], "metadata": {}}, "35fb1684-4a20-4e7f-a374-eac16b8a42b4": {"node_ids": ["ec950c06-ba9e-4ba6-ac1c-86921d56d6f1"], "metadata": {}}, "fd92e2aa-987b-42b9-8b0f-7ba363da2ace": {"node_ids": ["50e80d53-dfc3-402b-96f9-6ff0c7420f68"], "metadata": {}}}}