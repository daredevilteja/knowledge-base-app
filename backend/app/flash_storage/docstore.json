{"docstore/metadata": {"7c3ed5c2-22b2-4215-b065-4710571c590d": {"doc_hash": "e9e49c824fbaa176952b09fd439d0b1252b9495d54338a6b12b09f5aeb439251"}, "b485632a-551d-40c8-9db5-649e7612d816": {"doc_hash": "98f67bdd2e11c7f8f059b9db63ea7813bd44908545045b3d5c1baf3d7cc59b2e"}, "6c03bb40-ca0a-449c-98f7-bf0ef92eebcd": {"doc_hash": "89d42d1d254a9981ed9aa8624e1ec738b1ef2597bac223d465f77e730802b1f2"}, "396c8c2d-d8a6-4232-b3bb-623b78c7dbb2": {"doc_hash": "1a64eda223122d264afbc4a5e67a42fc7ffaccfacdbfe8d85c3c307e3f94a7c1"}, "9f3b69a8-a8f3-44c2-9285-5eacc5048966": {"doc_hash": "5d35adcc00077e41c4cb85009d9ac3129fe06f5d1bc834c123f704e9579c3663"}, "ff5df263-c393-4bf7-afda-2fe76ae0b014": {"doc_hash": "e97090c20703298b4ec7452470d18e8a1646731106c3680ccbe6e139d1d233bf"}, "d6ef9e51-de90-4990-8182-c0dbef8a7bb5": {"doc_hash": "620a1134db5db86575f5a58899e27b6db89e0e7e36b28ccd5be2868304067ece"}, "026edf98-f7cd-4def-84d0-af4d6bfa69b4": {"doc_hash": "4f7d7dc9b9ca594e8e8903992f1afefdaeaf4b6ff2d32242890b4334cd78ae42"}, "a5dbee3c-4a79-4543-b2b1-908c92b4a907": {"doc_hash": "e9c239e77c449784e0b5d902bac08537387ca81e6e05cf06c9bb86a8b49d2345"}, "12cb0b3e-3bbc-4452-8c83-0bc8dac09943": {"doc_hash": "01eec1d011655096e949ef630b6cd8cab9635c632fb0922f6cf41a92219b3370"}, "ca484c06-c775-4158-b7b3-00022c369c18": {"doc_hash": "607e27b588e0f050ba662a23c1c69acbe32217c0b92232fbea32e726cccc1bed"}, "7625525b-353c-457d-9333-c39e01ccab5d": {"doc_hash": "302a561776bc271ca8602b4f2f89b4fb5759142393d5d8523621af589b227393"}, "c04ae75a-80cf-4405-a5a4-0a3cb58d750d": {"doc_hash": "dfdc076e13736ccb3dcf4fad3a3da76e27ee74fbdfd18e4f6e1c478a7b60e6ce"}, "1db8ab12-0657-4974-a054-661e8ba8076e": {"doc_hash": "458fb1a183a82b6d948202353c0eba1e030bbdc98fc25ae67167822c2be9de4f"}, "0a2e85b1-938c-4a76-bb05-ad8ae47465ed": {"doc_hash": "125a20ccea0a31861620243a042baaeebe0487c86ca3895e99c9405b59238066"}, "8a3a914b-9f97-4f92-8571-4c7bbc9b0364": {"doc_hash": "92253d5ecfd9c1fafdf0353df68eaf9a702e029a9f81b2f6d3699cf8aa40b868"}, "3081f397-bfc3-4aee-933f-294d67337814": {"doc_hash": "3e12e6dea2bf55c3acb7b32434c3dfb0163f9caed76e8afa3ef5b93f90a4b5f2"}, "e1010cad-8da7-40ed-9e16-50d30b02986d": {"doc_hash": "8376a8f11f49540490576e7226beb3f3a62711dcc25693010678dc3c6af22a39"}, "b166836b-d0ae-4119-b667-7b80d6666703": {"doc_hash": "f9feb6c7daf16e65eab8d76d8d0a997a847516bd7f3c9592b1508d18fa49a2e0"}, "966c75da-9f72-4e6c-8885-87c6c22ea382": {"doc_hash": "c8b3d4e5d29cd5ce35274aae41dd7332561eb486b0f4a8373729c3e91a8eb75b"}, "671eab7f-ec86-43dc-8549-b0c4f1460082": {"doc_hash": "e9e49c824fbaa176952b09fd439d0b1252b9495d54338a6b12b09f5aeb439251", "ref_doc_id": "7c3ed5c2-22b2-4215-b065-4710571c590d"}, "48b37e0f-ebbb-469d-abcc-17812f7dedc2": {"doc_hash": "98f67bdd2e11c7f8f059b9db63ea7813bd44908545045b3d5c1baf3d7cc59b2e", "ref_doc_id": "b485632a-551d-40c8-9db5-649e7612d816"}, "8d90a360-0f4b-406b-af45-04c1f672a033": {"doc_hash": "89d42d1d254a9981ed9aa8624e1ec738b1ef2597bac223d465f77e730802b1f2", "ref_doc_id": "6c03bb40-ca0a-449c-98f7-bf0ef92eebcd"}, "c94ba9b2-171c-4436-bbbe-5648fbfa0976": {"doc_hash": "1a64eda223122d264afbc4a5e67a42fc7ffaccfacdbfe8d85c3c307e3f94a7c1", "ref_doc_id": "396c8c2d-d8a6-4232-b3bb-623b78c7dbb2"}, "db78cd10-fd01-4a7a-9df1-4e4a7c8678ea": {"doc_hash": "5d35adcc00077e41c4cb85009d9ac3129fe06f5d1bc834c123f704e9579c3663", "ref_doc_id": "9f3b69a8-a8f3-44c2-9285-5eacc5048966"}, "bc324e66-991f-465a-92a4-8d689147f56c": {"doc_hash": "e97090c20703298b4ec7452470d18e8a1646731106c3680ccbe6e139d1d233bf", "ref_doc_id": "ff5df263-c393-4bf7-afda-2fe76ae0b014"}, "fa26c9aa-8c87-4202-8611-ba2a2aec8392": {"doc_hash": "620a1134db5db86575f5a58899e27b6db89e0e7e36b28ccd5be2868304067ece", "ref_doc_id": "d6ef9e51-de90-4990-8182-c0dbef8a7bb5"}, "d836a08a-b98f-487d-9429-db17e66ad00e": {"doc_hash": "4f7d7dc9b9ca594e8e8903992f1afefdaeaf4b6ff2d32242890b4334cd78ae42", "ref_doc_id": "026edf98-f7cd-4def-84d0-af4d6bfa69b4"}, "d29dbcbe-e9ca-4456-8d00-d5440ff11174": {"doc_hash": "e9c239e77c449784e0b5d902bac08537387ca81e6e05cf06c9bb86a8b49d2345", "ref_doc_id": "a5dbee3c-4a79-4543-b2b1-908c92b4a907"}, "5286542b-4c20-44b6-be60-a7008d068599": {"doc_hash": "01eec1d011655096e949ef630b6cd8cab9635c632fb0922f6cf41a92219b3370", "ref_doc_id": "12cb0b3e-3bbc-4452-8c83-0bc8dac09943"}, "02c8c866-af01-46c8-9bde-e3bfaf51cbad": {"doc_hash": "607e27b588e0f050ba662a23c1c69acbe32217c0b92232fbea32e726cccc1bed", "ref_doc_id": "ca484c06-c775-4158-b7b3-00022c369c18"}, "4d9999c6-80ef-4a22-bfbf-ab0e9bcfd41d": {"doc_hash": "302a561776bc271ca8602b4f2f89b4fb5759142393d5d8523621af589b227393", "ref_doc_id": "7625525b-353c-457d-9333-c39e01ccab5d"}, "d2875d35-9d80-4970-a984-10ad61dbc66b": {"doc_hash": "dfdc076e13736ccb3dcf4fad3a3da76e27ee74fbdfd18e4f6e1c478a7b60e6ce", "ref_doc_id": "c04ae75a-80cf-4405-a5a4-0a3cb58d750d"}, "90359ef2-9f18-488c-a731-391fdcf1fbe9": {"doc_hash": "458fb1a183a82b6d948202353c0eba1e030bbdc98fc25ae67167822c2be9de4f", "ref_doc_id": "1db8ab12-0657-4974-a054-661e8ba8076e"}, "ea41e27f-c360-4de6-acfe-95aef8d9c52a": {"doc_hash": "125a20ccea0a31861620243a042baaeebe0487c86ca3895e99c9405b59238066", "ref_doc_id": "0a2e85b1-938c-4a76-bb05-ad8ae47465ed"}, "cf030f34-72d5-4332-91e1-81fac4ebaeb0": {"doc_hash": "92253d5ecfd9c1fafdf0353df68eaf9a702e029a9f81b2f6d3699cf8aa40b868", "ref_doc_id": "8a3a914b-9f97-4f92-8571-4c7bbc9b0364"}, "88966786-4f42-493c-9516-b997336c5036": {"doc_hash": "3e12e6dea2bf55c3acb7b32434c3dfb0163f9caed76e8afa3ef5b93f90a4b5f2", "ref_doc_id": "3081f397-bfc3-4aee-933f-294d67337814"}, "ec578717-d565-448e-9467-5a15997049d6": {"doc_hash": "8376a8f11f49540490576e7226beb3f3a62711dcc25693010678dc3c6af22a39", "ref_doc_id": "e1010cad-8da7-40ed-9e16-50d30b02986d"}, "bd2bb196-08f9-4098-b561-c37224e8be47": {"doc_hash": "f9feb6c7daf16e65eab8d76d8d0a997a847516bd7f3c9592b1508d18fa49a2e0", "ref_doc_id": "b166836b-d0ae-4119-b667-7b80d6666703"}, "20ca9fd8-70c0-49ef-9316-35f2015df506": {"doc_hash": "c8b3d4e5d29cd5ce35274aae41dd7332561eb486b0f4a8373729c3e91a8eb75b", "ref_doc_id": "966c75da-9f72-4e6c-8885-87c6c22ea382"}}, "docstore/data": {"671eab7f-ec86-43dc-8549-b0c4f1460082": {"__data__": {"id_": "671eab7f-ec86-43dc-8549-b0c4f1460082", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "7c3ed5c2-22b2-4215-b065-4710571c590d", "node_type": null, "metadata": {}, "hash": "e9e49c824fbaa176952b09fd439d0b1252b9495d54338a6b12b09f5aeb439251"}}, "hash": "e9e49c824fbaa176952b09fd439d0b1252b9495d54338a6b12b09f5aeb439251", "text": "Mastering State Management in Next.js<div><div>\n<p><strong>Summary (TL;DR)</strong>: In this article, we are going to explain how to manage state in Next.js by explaining what a state is, what state management entails and offer your a quick guide on state management through several methods, including React hooks, Context API, Redux and Data Fetching.</p>\n<figure></figure>\n<p>A \u201cstate\u201d is a JavaScript object which allows us to manage data and which is used to represent information about a component\u2019s value. State management is handling your application\u2019s UI and dictating what users see and what data is stored.</p>\n<p>State management is a core aspect of any application. Understanding state management will help keep code centralized and performant. It is very integral to the point that there are dedicated hooks and open-source libraries made specifically to make it easier.</p>\n<p>This article will enable us to understand state and how to manage it in Next.js using <a href=\"https://www.commoninja.com/blog/tips-and-tricks-for-better-react-development\">React hooks, Context API, Redux</a> and Data Fetching.</p>\n<p><strong><a href=\"https://www.commoninja.com/blog/react-18-news-and-features\">While You Are at It, Why Not Learn More About The Newest Version of React \u2013 React 18</a></strong></p>\n<h2>Table of Contents</h2>\n<p><a href=\"#What-Is-State\">What Is State?<br /></a><a href=\"#What-Is-State-Management\">What Is State Management?<br /></a><a href=\"#A-Brief-Look-at-the-Nextjs-File-Structure\">A Brief Look at the Next.js File Structure<br /></a><a href=\"#React-Hooks-for-Managing-State\">React Hooks for Managing State<br /></a><a href=\"#Context-API-for-Complex-State\">Context API for Complex State<br /></a><a href=\"#Redux\">Redux<br /></a><a href=\"#Managing-the-State-With-Data-Fetching\">Managing the State With Data Fetching</a></p>\n<h2>What Is State</h2>\n<p>A state is the internal value of a React component at any given point. It can contain various data types like arrays and objects. It can also be known as a dynamic store for managing application data. A state holds the current value of data. For example, a state can hold one value from a list of values coming from a server but might hold a different value when a button is clicked.</p>\n<h2>What Is State Management?</h2>\n<p>State management is the process of handling and maintaining knowledge of the state of an application. State management determines which data to show and how to show them as users interact with the application. This management usually handles the state of user interface control systems like input fields, CTA buttons, etc.</p>\n<p>Some benefits of state management include centralizing and easy maintenance of code, making data handling easy, reducing code size, and doing away with dead code.</p>\n<h2>A Brief Look at the Next.js File Structure</h2>\n<p>Understanding the file structure in a Next.js file enables a better understanding of the different ways to store and handle state. </p>\n<p>A new Next.js application consists of a pages, style and public folders. Inside the pages folder, which we will concentrate on in this article, we have two files: the index.js and the _app file, and an api folder. The _app file holds all globally accessible components, while the api folder contains the app\u2019s API endpoint.</p>\n<h2>React Hooks for Managing State</h2>\n<p>Before introducing hooks in React V16.8, the state could only be accessed and managed using this.state variable, and the data type is always an object. The introduction of hooks took out the need for the this.state variable. </p>\n<p>Hooks are functions that allow you to use React features without the need for writing classes. They \u201chook\u201d into lifecycle features and will enable you to reuse logic without affecting component hierarchy.</p>\n<p>This section", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "48b37e0f-ebbb-469d-abcc-17812f7dedc2": {"__data__": {"id_": "48b37e0f-ebbb-469d-abcc-17812f7dedc2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "b485632a-551d-40c8-9db5-649e7612d816", "node_type": null, "metadata": {}, "hash": "98f67bdd2e11c7f8f059b9db63ea7813bd44908545045b3d5c1baf3d7cc59b2e"}}, "hash": "98f67bdd2e11c7f8f059b9db63ea7813bd44908545045b3d5c1baf3d7cc59b2e", "text": "Managing Data and State: React Hooks, Recoil and Apollo GraphQL Client<div><div><p>State and data management have proven to be complicated endeavors over time as React has evolved as a library. From the good old fashioned, built-in <code>setState</code> method of class based components, to a composition mindset brought to us by libraries like <a href=\"https://github.com/acdlite/recompose\">Recompose</a> (remember that one?) - we've had enough to keep our plates full over the years... and then some. High-Order Components, render props, global state, actions, reducers, memoization, side effects... the list goes on and on when we take a trip down memory lane. All of this to accomplish one main thing - UI data and state management. React Hooks have standardized a bit of this, specifically when it comes to local state management. In this post, I'll illustrate some real world patterns I've established in building the new <a href=\"https://www.foo.software/\">www.foo.software</a>.</p><h2>App Loading State with Custom React Hooks and Recoil</h2><p>I decided to establish an app level \"loading\" state as a dictionary-like data structure (example below). Each line represents a part of the app in a loading state. When all parts have completed loading, the object will be empty.</p><pre><code>{\n \"userFetch\": \"userFetch\",\n \"someOtherDataFetch\": \"someOtherDataFetch\"\n}</code></pre><p>With the above in mind, I created a Recoil \"atom\" to hold this \"loading\" piece of global state.</p><blockquote>An <strong>atom</strong> represents a piece of <strong>state</strong>. Atoms can be read from and written to from any component. Components that read the value of an atom are implicitly <strong>subscribed</strong> to that atom, so any atom updates will result in a re-render of all components subscribed to that atom</blockquote><p>~ <a href=\"https://recoiljs.org/docs/introduction/getting-started\">Getting Started | Recoil</a></p><pre><code>// state/loadingState.ts\nimport { atom } from 'recoil';\nexport type LoadingCollectionType = Record&lt;string, string&gt;;\nexport const loadingState = atom({\n key: 'loadingState',\n default: {} as LoadingCollectionType,\n});</code></pre><h3>Combining useEffect React Hook with useRecoilState</h3><p>Recoil offers many benefits - one being its compatibility and adoption of hooks. The library <a href=\"https://recoiljs.org/docs/api-reference/core/useRecoilState/\">provides a <code>useRecoilState</code> hook</a> that is pretty robust in that it supports selectors (which I won't get into in this post). Below you can see how I use the hook to set and remove loading state based on <code>id</code> (being the <code>key</code> of the key / value pair collection encompassing my loading state).</p><pre><code>// state/useLoading.ts\nimport { useEffect } from 'react';\nimport { useSetRecoilState } from 'recoil';\nimport { loadingState } from './loadingState';\nexport default function useLoading({\n id,\n shouldShowLoading,\n}: {\n id: string;\n shouldShowLoading: boolean;\n}) {\n const setLoading = useSetRecoilState(loadingState);\n useEffect(() =&gt; {\n const removeLoadingState = () =&gt; {\n setLoading((oldLoading) =&gt; {\n const { [id]: _removed, ...updatedLoading } = oldLoading;\n return updatedLoading;\n });\n };\n if (shouldShowLoading) {\n setLoading((oldLoading) =&gt; ({\n ...oldLoading,\n [id]: id,\n }));\n } else {\n removeLoadingState();\n }\n // if component unmounts while in loading state,we need to make\n // sure we cleanup with `useEffect` unsubscribe (end loading state)\n return () =&gt; {\n removeLoadingState();\n };\n }, [shouldShowLoading]);\n};</code></pre><p", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "8d90a360-0f4b-406b-af45-04c1f672a033": {"__data__": {"id_": "8d90a360-0f4b-406b-af45-04c1f672a033", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6c03bb40-ca0a-449c-98f7-bf0ef92eebcd", "node_type": null, "metadata": {}, "hash": "89d42d1d254a9981ed9aa8624e1ec738b1ef2597bac223d465f77e730802b1f2"}}, "hash": "89d42d1d254a9981ed9aa8624e1ec738b1ef2597bac223d465f77e730802b1f2", "text": "Past, Present, and Future of React State Management<div><section><article><p>React was introduced in May 2013. Its paradigm shift was that <strong>your UI was a function of your state</strong>. Given some component state, React can determine what your component will look like. React is <em>built</em> upon the idea of state. However, state has long been one of the most difficult parts of building a React application.</p>\n<p>Let's imagine state management in React as a rugged tool belt. You've used this tool belt for years, slowly adding new tools as needed. Each tool serves a very specific purpose. You don't use your hammer to screw in bolts. As a craftsman, you've learned the right time and place to use each tool.</p>\n<p><strong>State management with React is a rugged tool belt, but not everyone has the prior experience to know which tool to reach for.</strong> This post will explain the past, present, and future of state management to help you make the correct decision for your team, project, or organization.</p>\n<h2><a href=\"#glossary\"></a>Glossary</h2>\n<p>Before we begin, it's critical you understand some of the terms commonly used. These aren't the canonical names. A few different variations of each float around, but the underlying ideas are the same:</p>\n<ul>\n<li>UI State \u2013 State used for controlling interactive parts of our application (e.g. dark mode toggle, modals).</li>\n<li>Server Cache State \u2013 State from the server, which we cache on the client-side for quick access (e.g. call an API, store the result, use it in multiple places).</li>\n<li>Form State \u2013 The many different states of a form (e.g. loading, submitting, disabled, validation, retrying). There's also <a href=\"https://reactjs.org/docs/forms.html\">controlled &amp; uncontrolled form state</a>.</li>\n<li>URL State \u2013 State managed by the browser (e.g. filter products, saving to query parameters, and refreshing the page to see the same products filtered)</li>\n<li>State Machine \u2013 An explicit model of your state over time (e.g. a stoplight goes from green \u2192 yellow \u2192 red, but never green \u2192 red).</li>\n</ul>\n<h2><a href=\"#past\"></a>Past</h2>\n<p>React's component model helped create reusable, composable applications. Each component had its own local state. As web apps became more complex, new solutions emerged to more easily share logic between components.</p>\n<h3><a href=\"#timeline\"></a>Timeline</h3>\n<p>To help you understand how state management has evolved over time, here's a rough timeline of popular state management solutions in React. This list is heavily focused on UI State. This list is not comprehensive, but is enough to give context.</p>\n<ul>\n<li>2013 \u2013 Introduction</li>\n<li>2014 \u2013 Flux (many libraries)</li>\n<li>2015 \u2013 Redux</li>\n<li>2016 \u2013 MobX</li>\n<li>2018 \u2013 Context</li>\n<li>2019 \u2013 Hooks Introduced (+ React Query, SWR)</li>\n<li>2019 \u2013 Zustand</li>\n<li>2019 \u2013 xState</li>\n<li>2020 \u2013 Jotai, Recoil, Valtio</li>\n<li>2021 \u2013 useSelectedContext</li>\n</ul>\n<p>Just because an item is listed on this timeline does not mean you need to learn it. More on this later. Let's dive into the history of state management in React.</p>\n<h3><a href=\"#redux\"></a>Redux</h3>\n<p><a href=\"https://redux-toolkit.js.org/\">Redux</a> was originally created as an implementation of the \"<a href=\"https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/#redux-was-built-as-a-flux-architecture-implementation\">Flux Architecture</a>\", which was a pattern first suggested by Facebook in 2014. Redux came out in 2015 and quickly became the most popular of many Flux-inspired libraries. It's ecosystem of tools and libraries encapsulated both UI state", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "c94ba9b2-171c-4436-bbbe-5648fbfa0976": {"__data__": {"id_": "c94ba9b2-171c-4436-bbbe-5648fbfa0976", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "396c8c2d-d8a6-4232-b3bb-623b78c7dbb2", "node_type": null, "metadata": {}, "hash": "1a64eda223122d264afbc4a5e67a42fc7ffaccfacdbfe8d85c3c307e3f94a7c1"}}, "hash": "1a64eda223122d264afbc4a5e67a42fc7ffaccfacdbfe8d85c3c307e3f94a7c1", "text": "Demystifying state management<div><div>\n <p>\n </p>\n <div>\n <p><a href=\"/kevtiq\"></a>\n </p>\n \n </div>\n </div><div>\n <p>State management is one of the most complicated, and opinionated topics in modern and JavaScript-focused front-end development. But at its core, it is not that complicated. We just make it complicated. In this article I will try to demystify state and state management for you, and challenge your mental models around them. </p>\n<h2>\n <a href=\"#what-are-state-and-state-management\">\n </a>\n What are state and state management?\n</h2>\n<p>Is state some weird data storage? Is it the data from a database? No. State is nothing more than a JavaScript value that lives within in scope. It can be a boolean, a string, but is in most cases a (complex) object. But it remains a value. In most cases, it is even an object living on the same level as the <code>window</code> object. It has become a global value in the JavaScript environment, the browser window. From our code (e.g. UI components), we can use this value to determine what to show or what interactions to allow. In complex applications there are a few different types of state we can have. But remember, they are nothing more than values. </p>\n<ul>\n<li>\n<strong>Local</strong>: state that is used by a single UI component.</li>\n<li>\n<strong>Shared</strong>: state that is used by many UI components. It is often managed in a parent or wrapper component.</li>\n<li>\n<strong>Global</strong>: a special kind of <em>shared</em> state, as it lives on the highest level, accessible to all UI components (or even helper functions).</li>\n<li>\n<strong>Meta</strong>: also known as 'state about state'. It tells you something about</li>\n<li>\n<strong>Route</strong>: state stored in the current URL of the application (e.g. object IDs or pagination information).</li>\n<li>\n<strong>Remote</strong>: a copy of the data coming from a server. The responses of fetch requests are stored as 1-on-1 copies in this state. It should not deviate from the server (except when applying <a href=\"https://www.smashingmagazine.com/2016/11/true-lies-of-optimistic-user-interfaces/\">optimistic UI</a>).</li>\n</ul>\n<p>So what about state management? For many, state management feels like a black box. What is happening within Redux? Why does it feel so complicated. I look at it this way: state management is nothing more than patterns we use to make using and changing state, manageable. It is not black box magic, it is just patterns. Why not group all the mutations you can make on your state in one place? And how about giving these mutations simple, but understandable names? In complex applications, adopting these types of patterns makes our code more maintainable. Or so they say (it is true though). In the sections below, we go deeper into different kind of state management patterns. </p>\n<h2>\n <a href=\"#eventdriven-pattern\">\n </a>\n Event-driven pattern\n</h2>\n<p>The best-known pattern is the flux pattern. It gained popularity with the 'Redux' package. It is a great example of an event-driven pattern. Let's take a closer look at its flow. The user, via the view, dispatches an action, via an action creator. It might seem daunting or overly complex. But it is nothing more as I said before. It is a way to group all possible state mutations together, and allow us to use simple 'actions' with memorable names from our UI components. </p>\n<p><a href=\"https://res.cloudinary.com/practicaldev/image/fetch/s--N33N6ZEZ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7xa0exqvu0q9y708fbjz.png\"></a></", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "db78cd10-fd01-4a7a-9df1-4e4a7c8678ea": {"__data__": {"id_": "db78cd10-fd01-4a7a-9df1-4e4a7c8678ea", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9f3b69a8-a8f3-44c2-9285-5eacc5048966", "node_type": null, "metadata": {}, "hash": "5d35adcc00077e41c4cb85009d9ac3129fe06f5d1bc834c123f704e9579c3663"}}, "hash": "5d35adcc00077e41c4cb85009d9ac3129fe06f5d1bc834c123f704e9579c3663", "text": "Derived state - Underrated Pro tip for simplifying React state management<div><article>\n \n <figure>\n \n \n \n \n \n \n \n</figure>\n<p>In my opinion, state management is the most challenging part of building and scaling web applications. I would even argue that developers mainly get paid to write sound state management machines. All the other parts can be outsourced or automated (and often are) using UI libraries and NPM packages.</p>\n<p>In this post, I want to cover a state management technique called \u201cDerived state\u201d which I think is underrated. In many cases, it can simplify your state management logic. The \u201cDerived state\u201d technique is library-agnostic, and you can apply it to Redux, MobX, and React\u2019s built-in state management hooks.</p>\n<h2>What is the derived state?</h2>\n<p>The idea is to lean towards storing the least amount of data possible in your state. The way to go about it is to avoid storing state variables that you can derive or compute on the fly.</p>\n<p>Computing the variables rather than storing them in the state makes it easier to keep your data in sync when changes occur.</p>\n<h2>Example of derived state</h2>\n<p>Let take a look at an example. Say you have a song selector which consists of checkboxes for each song. Songs are also grouped by genre. We want to be able to select an individual song as well as the whole genre:<br />\n</p><figure>\n \n \n \n \n \n \n \n</figure>\n<p>Now your first thought might be to create two state variables: one for storing selected songs selected and the other for genres. Seems simple enough, but is that the best way to go about it? Do we <em>really</em> need two variables for this?</p>\n<p>In this example, we can actually derive the value of genre checkboxes based on the value of individual song checkboxes. Here\u2019s what it would look like:<br />\n</p><figure>\n \n \n \n \n \n \n \n</figure>\n<p>The value of a genre checkbox is computed on the fly using <code>isGenreChecked</code> method and <code>songSelections</code> object. A genre is checked only when all the songs under it are selected. When users click on a genre checkbox all we need to do is select/deselect all of the items under that genre.</p>\n<h2>Why use this technique?</h2>\n<p>So why is this approach better? As I mentioned earlier, it\u2019s much easier to keep our state in sync. The reason for it is that we have a single source of truth - our selected songs. Having a single state variable that you need to keep track of, while all other ones derived from it, simplifies the state mutation.</p>\n<p>For example, when unchecking a single song, we no longer need to worry about updating the state of its parent genre. On the new render, the app will recompute the state of the genre and automatically uncheck it.</p>\n<h2>Performance concerns</h2>\n<p>You may have performance concerns around recomputing the values of the state variables on each render. There might indeed be a performance overhead depending on the complexity of computation of the derived state.</p>\n<p>If there\u2019s a noticeable performance regression, you can invest in optimizing your application. For example, you can wrap your computed value using the <a href=\"https://reactjs.org/docs/hooks-reference.html#usememo\">\n useMemo\n</a> hook to avoid recomputing the derived variable unless its underlying state has changed.</p>\n<h2>Conclusion</h2>\n<p>In this post, we covered a state management optimization technique called \u201cDerived State.\u201d \u201cDerived State\u201d helps you simplify your code by reducing the number of variables you need to store in your state.</p>\n<p>Next time you\u2019re building a state management piece, you can consider using this technique and see whether certain state variables can be computed on the fly rather than stored in the state.</p>\n<p>If you\u2019d like to get more web development, React and TypeScript tips consider <a href=\"https://twitter.", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "bc324e66-991f-465a-92a4-8d689147f56c": {"__data__": {"id_": "bc324e66-991f-465a-92a4-8d689147f56c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ff5df263-c393-4bf7-afda-2fe76ae0b014", "node_type": null, "metadata": {}, "hash": "e97090c20703298b4ec7452470d18e8a1646731106c3680ccbe6e139d1d233bf"}}, "hash": "e97090c20703298b4ec7452470d18e8a1646731106c3680ccbe6e139d1d233bf", "text": "React State Management Libraries and How to Choose<div><div>\n <p>The idea of <em>state</em> is one of the trickier things to nail down when you\u2019re starting with React, and as your app grows, so do your state management needs.</p>\n<p>In this post I\u2019ll give you the Grand Tour of state management options in React and help you decide which one to use in your project.</p>\n<h2>What is State?</h2>\n<p>Just so we\u2019re on the same page, let\u2019s talk about <strong>state</strong> for a second.</p>\n<p>Every interactive app involves responding to events, like when the user clicks a button, and a sidebar closes. Or someone sends a message, and it appears in a chat window.</p>\n<p>As these events happen, and the app is updated to reflect them, we say the <em>state of the app</em> has changed. The app looks different than it did before, or it\u2019s in a new mode behind the scenes.</p>\n<p>Things like, \u201cwhether the sidebar is open or closed\u201d and \u201cthe messages in the chat box\u201d are <em>pieces of state</em>. In programming terms, you\u2019d probably have an <code>isSidebarOpen</code> variable somewhere in the app set to <code>true</code>, and a <code>chatMessages</code> array with the messages you\u2019ve received.</p>\n<p>At any given moment, broadly speaking, the \u201cstate of your app\u201d is determined by all of that data. All those individual variables, whether they\u2019re stored in local component state or some third-party state management store \u2013 that\u2019s your app\u2019s state.</p>\n<p>This is the high-level concept of \u201capp state\u201d. We aren\u2019t talking about React-specific stuff like <code>useState</code> or Context or Redux or anything yet.</p>\n<h2>What is State Management?</h2>\n<p>All of those variables that decide what state your app is in have to be stored somewhere. So state management is a broad term that combines <em>how you store the state</em> and <em>how you change it</em>.</p>\n<p>React and its ecosystem offer lots of different ways to store and manage that state. And when I say lots I mean LOTS.</p>\n<h3>Storing the Data</h3>\n<p>For storage, you can\u2026</p>\n<ul>\n <li>keep those variables in local component state \u2013 whether that\u2019s with hooks (<code>useState</code> or <code>useReducer</code>) or in classes (<code>this.state</code> and <code>this.setState</code>)</li>\n <li>keep the data in a store, using a third-party library like Redux, MobX, Recoil, or Zustand</li>\n <li>you can even keep them on the <code>window</code> object globally</li>\n</ul>\n<p>React doesn\u2019t care an ounce where you put the data, but\u2026</p>\n<h3>Updating the Data and Re-rendering</h3>\n<p>To make your app interactive, you need a way for React to know that something changed, and that it should re-render some (or all) components on the page.</p>\n<p>Because React, despite its name, is not \u201creactive\u201d in the way some other frameworks are.</p>\n<p>Some frameworks \u201cwatch\u201d for things, and update accordingly. Angular, Svelte, and Vue do this, among others.</p>\n<p>React doesn\u2019t, though. It does not \u201cwatch for changes\u201d and magically re-render. You (or something) needs to tell it to do that.</p>\n<ul>\n <li>with <code>useState</code>, <code>useReducer</code>, or <code>this.setState</code> (classes), React will re-render when you call one of the setter functions</li>\n <li>if you keep the data in Redux, MobX, Recoil, or some other store, then that store will tell React when something has changed,", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "fa26c9aa-8c87-4202-8611-ba2a2aec8392": {"__data__": {"id_": "fa26c9aa-8c87-4202-8611-ba2a2aec8392", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d6ef9e51-de90-4990-8182-c0dbef8a7bb5", "node_type": null, "metadata": {}, "hash": "620a1134db5db86575f5a58899e27b6db89e0e7e36b28ccd5be2868304067ece"}}, "hash": "620a1134db5db86575f5a58899e27b6db89e0e7e36b28ccd5be2868304067ece", "text": "Why React Contexts Are Great and Why We Didn't Use Them<div><div>\n \n <main>\n <article>\n \n \n <p> </p>\n \n <div>\n \n \n <div>\n \n <p>Web apps maintain state to enable more advanced user interactions. When we enter an email into a website, we expect that website to remember the email and not have to enter it over and over each time it displays. One way to remember information across renders in <a href=\"https://reactjs.org/\">React</a> is with state, specifically useContext hooks. I looked at useContexts and started using them in a project but ultimately went with component props instead. Here is what I learned in the process.</p>\n<p></p>\n<p>React context allows a state object to be read and written to form any component that imports the useContext hook and access to a provider in the component hierarchy. The state can be any collection of variables and functions. The provider is a React component that sets the initial state and allows all descendants to access the state. This simplicity makes React contexts flexible. It also allows for multiple different contexts within a web app depending on which components the app renders. You can modify the variables in a React context with functions that are a part of the state itself. Benefits of using React\u2019s context include ease of importing and the ability to add the useContext hook to any component without modifying the props.</p>\n<h2>Where did we find problems?</h2>\n<p>We learned about useContext and started implementing it on our project to store information across all steps in a user workflow. We added the information the workflow needed and quickly saw the context state expanding with functions and variables. This on its own wasn\u2019t a major issue. The state type was all in one file, which stayed readable.</p>\n<p>The problem was that it became too tempting to modify variables that the current workflow step shouldn\u2019t have had any power over. When a component imports useContext, it gains read and write access to the full state. The workflow developed hard-to-diagnose bugs that involved the state object being manipulated in unexpected ways. Within four weeks of development, the state was enabling interesting behaviors. We could click a button and changes would propagate through multiple steps and components. However, the code became difficult to maintain and understand, even on a small team where everyone had full knowledge of the codebase.</p>\n<h2>What did we do instead?</h2>\n<p>We decided to shift to a state object that is propped down from component to component. The benefit was that we could check at each layer to ensure the types only exposed the attributes and the functions that the component was interested in. This helped us keep the responsibilities of each component narrow and improved the readability of the code.</p>\n<p>We found React Contexts enabled easy data sharing. However, this tool requires discipline to effectively control what is on the context and what can edit it. Did my team miss an opportunity by not making use of React contexts? Were the issues we bumped into a problem of our understanding or problems inherent in the tool? Let me know in the comments, and always experiment to find the right patterns for each project.</p>\n \n </div>\n <div>\n <h3>Related Posts</h3>\n <ul>\n <li>\n <a href=\"https://spin.atomicobject.com/platforms-languages/react-redux/\">React / Redux</a>\n <h2><a href=\"https://spin.atomicobject.com/2023/01/26/remix-routing/\">How to Get Data from a Parent Component in Remix</a></h2>\n </li>\n <li>\n <a href=\"https://spin.atomicobject.com/platforms-languages/react-redux/\">React / Redux</a>\n <h2><a href=\"https://spin.atomicobject.com/2022/12/13/react-dnd-beautiful/\">Use React DND Beautiful to Create a Drag and Drop Component in a Next.js App</a></h2>\n </li>\n <li>\n <a href=\"https://spin.atomicobject.com/platforms-languages/react-redux/\">React / Redux</a>\n <h2><a href=\"https://spin.atomicobject.com/2022/11/17/dynamic-anchor-tags/\">Using Dynamic Anchor Links", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "d836a08a-b98f-487d-9429-db17e66ad00e": {"__data__": {"id_": "d836a08a-b98f-487d-9429-db17e66ad00e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "026edf98-f7cd-4def-84d0-af4d6bfa69b4", "node_type": null, "metadata": {}, "hash": "4f7d7dc9b9ca594e8e8903992f1afefdaeaf4b6ff2d32242890b4334cd78ae42"}}, "hash": "4f7d7dc9b9ca594e8e8903992f1afefdaeaf4b6ff2d32242890b4334cd78ae42", "text": "React state management in 3 lines<div><article><div><p>\ud83d\udccc</p><p>I talked about my mental model about state management in React in previous <a href=\"/state-management-in-react\">post</a>, this post is an implementation about that.</p></div><h3><a href=\"#5c2c9996c6c1412c9492e94a1423bb3c\"></a>TL;DR</h3><ol><li><code>npm install unstated-next immer use-immer</code></li></ol><ol><li>create a <code>store.ts</code> file with 3 lines of code (\ud83d\udc47)</li><ol><pre><code>// store.ts\nimport { createContainer } from 'unstated-next'\nimport { useImmer } from 'use-immer'\nexport default createContainer(state =&gt; useImmer(state))</code></pre></ol></ol><ol><li>\ud83c\udf89\ud83c\udf89\ud83c\udf89</li></ol><hr /><h3><a href=\"#ed0c172903584e9183fded8511c6d43b\"></a>Problem</h3><p>Have you ever experienced analysis paralysis in the world of React while trying to understand what <a href=\"https://en.wikipedia.org/wiki/The_Paradox_of_Choice\">The Paradox of Choices</a> means? The fact that React is so unopinionated that it offloads the burden of having strong opinions onto you, the developer, who is responsible for building something more than a \"Hello World\" demo.</p><p>Every day, a new state management solution emerges, including Redux, Mobx, React.Context, Jotai, Zustand, and others. Each has its unique features, which is why there are numerous online tutorials about them. However, the question remains: which one should we choose if we want to simply Get Stuff Done (GSD) instead of getting stuck in certain rabbit holes?</p><h3><a href=\"#f69153cd20a94b4eb31469088ef9a5df\"></a>Inspiration</h3><p>If we can suspend our judgement temporarily and let go of the pride of winning the popularity contest for a moment, we may find something quite pragmatic from our peer frameworks. And of course, we will. There will always be inspirations to draw from others, similar to how they learn from React.</p><p>In Vue 3, there is a new Composition API paired with Immer.js that literally turns Vue into React. See how Evan weaves his magic in just a few lines of code.</p><div><pre><code>const { state: items, update } = useImmer([\n {\n title: \"Learn Vue\",\n done: true\n },\n {\n title: \"Use Vue with Immer\",\n done: false\n }\n])</code></pre><figcaption>Vue 3 todo example</figcaption></div><p>Although it looks simple and clean, it doesn't provide much of a selling point to me because Vue and Immer.js have many similarities in terms of state mutations, <em>from a developer point of view</em>. They both allow us to mutate state in a way that's similar to how we mutate JavaScript objects, without working against the JavaScript language.</p><p>But how about React? Could it be possible to bring the same idea to React and make React more Vue-ish?</p><h3><a href=\"#78f6282139f145dba3c5ca0406d26081\"></a>Solution</h3><div><p>Turns out, it's not that difficult to achieve (you only need </p><p>+ </p><p>). It has the same benefit of using React.Context, but unlike hooks, state can be shared across components. What is more is that it enhances React.Context with Immer so that you can update state just like you\u2019re mutating object in javascript. </p></div><p>Additionally, Unstated Next enhances React.Context with Immer, allowing you to update state just like you would mutate an object in JavaScript. Think of it as replacing React's <code>setState</code> with Immer's <code>update</code> function, while everything else remains the same.</p><div><pre><code>import store from './store'\n// useContainer is a React hook from https", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "d29dbcbe-e9ca-4456-8d00-d5440ff11174": {"__data__": {"id_": "d29dbcbe-e9ca-4456-8d00-d5440ff11174", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a5dbee3c-4a79-4543-b2b1-908c92b4a907", "node_type": null, "metadata": {}, "hash": "e9c239e77c449784e0b5d902bac08537387ca81e6e05cf06c9bb86a8b49d2345"}}, "hash": "e9c239e77c449784e0b5d902bac08537387ca81e6e05cf06c9bb86a8b49d2345", "text": "How to avoid tricky async state manager pitfalls in React\u2014Martian Chronicles, Evil Martians\u2019 team blog<div><div><p>These days, the local-first approach for building web apps is gaining more and more popularity. Most of these databases provide async APIs, and that make a big difference with our React apps. Read on to find out how to nip any potential problems in the bud.</p><p>Let\u2019s recap the local-first approach for building web applications. When building apps this way, user data is stored locally. This means that it\u2019s rapidly accessible, and thus, we can abstract away all the server communication and network error handling.</p><p>A core part of local-first applications are local databases. These provide APIs for our apps to read and write data, and we can also use the API to subscribe to look out for changes as well as synchronize changes over the network with the server, other users, or instances of the app in other browser tabs. </p><p>Examples include <a href=\"/products/logux\">Logux</a>, <a href=\"https://replicache.dev/\">Replicache</a>, <a href=\"https://rxdb.info/\">RxDB</a>, and <a href=\"https://github.com/Nozbe/WatermelonDB\">WatermelonDB</a>.</p><figure><div></div></figure><h2>The problem with local-first databases async APIs</h2><p>These databases provide asynchronous APIs. This means that any changes made are not applied immediately, and during this time, it\u2019s possible for stale data to be read.</p><p>Even though this time lag is very small, it makes a big difference for React. When changes and their corresponding effects happen asynchronously, many familiar patterns (like controlled text fields or transitions) will cease to functon correctly.</p><p>To illustrate the problem, let\u2019s imagine we want to create a text field with persistency. It will be connected to a fictitious storage called <code>MyStorage</code> (which represents a local database) and text content will be saved in this storage upon each change.</p><h2>Synchronous example</h2><p>Assuming <code>MyStorage</code> is synchronous, the code will be very simple, and familiar to every React developer:</p><div><pre><code>function PersistedTextField() {\n\tconst [text, setText] = useMyStorage()\n\treturn &lt;input value={text} onChange={(event) =&gt; setText(event.target.value)} /&gt;\n}</code></pre></div><h2>Text fields and asynchronous storage</h2><p>However, If <code>MyStorage</code> has an asynchronous API, then the pattern above won\u2019t work as expected: instead, every keystroke will reset the cursor position to the end of the text field. This makes it very troublesome to fix a typo in the middle of the text. </p><figure></figure><p>Let\u2019s unpack why this happens. </p><p>Each keystroke has two effects: </p><ol><li>The value of the input component in the DOM (and the virtual DOM) is updated.</li><li>The <code>onChange</code> handler is called to update storage.</li></ol><p>Immediately after this, React performs its reconciliation cycle by comparing the value in the virtual DOM with the value in storage. Since the storage has not yet been updated, React notes the difference and rolls back the DOM value of the input to the previous state. </p><p>After the value has been saved to storage, React does the same thing again and finally applies the new value. </p><p>This happens very fast, but during this same period of time, React updates the input\u2019s value programmatically two times. And this programmatic update has the side effect of reseting the cursor position to the end of the input.</p><p>To further clarify the contrast with the previous example, with the synchronous API, React will see the updated value in the DOM as well as the updated value in storage; this means it doesn\u2019t have to update anything programmatically.</p><h2>Further issues with asynchronous storages</h2><p>Let\u2019s look at another place where a problem caused by asynchronous API can crop up: animations during drag-and-drop sorting. </p><p>Imagine a", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "5286542b-4c20-44b6-be60-a7008d068599": {"__data__": {"id_": "5286542b-4c20-44b6-be60-a7008d068599", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "12cb0b3e-3bbc-4452-8c83-0bc8dac09943", "node_type": null, "metadata": {}, "hash": "01eec1d011655096e949ef630b6cd8cab9635c632fb0922f6cf41a92219b3370"}}, "hash": "01eec1d011655096e949ef630b6cd8cab9635c632fb0922f6cf41a92219b3370", "text": "The new wave of React state management<div><div><article><h2>Introduction</h2><p>As React applications grow in size and complexity, managing shared global state is challenging. The general advice is to only reach for global state management solutions when needed.</p><p>This post will flesh out the core problems global state management libraries need to solve.</p><p>Understanding the underlying problems will help us assess the tradeoffs made in the \u201cnew wave\u201d of state management approaches. For everything else, it\u2019s often better to start local and scale up only as needed.</p><p>React itself does not provide strong guidelines for solving this for shared global application state. As such, the React ecosystem has collected numerous approaches and libraries to solve this problem over time.</p><p>This can make it confusing when assessing which library or pattern to adopt.</p><p>The common approach is to outsource this and use whatever is most popular. Which as we\u2019ll see, was the case with the widespread adoption of Redux early on, with many applications not needing it.</p><p>Understanding the problem space state management libraries operate in allows us to better understand why so many different libraries take different approaches.</p><p>Each makes different tradeoffs against different problems, leading to numerous variations in API\u2019s, patterns, and conceptual models on how to think about state.</p><p>We\u2019ll take a look at modern approaches and patterns that can be found in libraries like <a href=\"https://recoiljs.org/\">Recoil</a>, <a href=\"https://jotai.org/\">Jotai</a>, <a href=\"https://github.com/pmndrs/zustand\">Zustand</a>, <a href=\"https://github.com/pmndrs/valtio\">Valtio</a> and how others like <a href=\"https://github.com/dai-shi/react-tracked\">React tracked</a> and <a href=\"https://react-query.tanstack.com/overview\">React query</a> and how fit into the ever evolving landscape.</p><p>By the end, we should be more equipped to accurately assess libraries\u2019 trade-offs when choosing one that makes sense for our application\u2019s needs.</p><h2>The problems global state management libraries need to solve</h2><ol><li><p><strong>Ability to read stored state from anywhere in the component tree.</strong> This is the most basic function of a state management library.</p><p>It allows developers to persist their state in memory, and avoid the issues prop drilling has at scale. Early on in the React ecosystem we often reached for Redux unnecessarily to solve this pain point.</p><p>In practice there are two main approaches when it comes to actually storing the state.</p><p>The first is inside the React runtime. This often means leveraging API\u2019s React provides like <code>useState</code>, <code>useRef</code> or <code>useReducer</code> combined with React context to propagate a shared value around. The main challenge here is optimizing re-renders correctly.</p><p>The second is outside of React\u2019s knowledge, in module state. Module state allows for singleton-like state to be stored. It\u2019s often easier to optimize re-renders through subscriptions that opt-in to re-rendering when the state changes. However, because it\u2019s a single value in memory, you can\u2019t have different states for different subtrees.</p></li><li><p><strong>Ability to write to stored state.</strong> A library should provide an intuitive API for both reading and writing data to the store.</p><p>An intuitive API is often one that fits ones existing mental models. So this can be somewhat subjective depending on who the consumer of the library is.</p><p>Often times clashes in mental models can cause friction in adoption or increase a learning curve. A common clashing of mental models in React is mutable versus immutable state.</p><p>React\u2019s model of UI as a function of state lends itself to concepts that rely on referential equality and immutable updates to detect when things change so it can re-render correctly. But Javascript is a mutable language.</p><p>When using React, we have to keep things like reference equality in mind. This can be a source of confusion for Javascript developers not used to functional concepts and forms part of the learning curve when using React.</p><p>Redux follows this model and requires all state updates", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "02c8c866-af01-46c8-9bde-e3bfaf51cbad": {"__data__": {"id_": "02c8c866-af01-46c8-9bde-e3bfaf51cbad", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ca484c06-c775-4158-b7b3-00022c369c18", "node_type": null, "metadata": {}, "hash": "607e27b588e0f050ba662a23c1c69acbe32217c0b92232fbea32e726cccc1bed"}}, "hash": "607e27b588e0f050ba662a23c1c69acbe32217c0b92232fbea32e726cccc1bed", "text": "React state management - useReducer vs Redux<div><div>\n \n<article>\n <p>One of the core concepts of React library is state which is responsible for the UI changes.</p>\n<p>We have multiple solutions to manage state in the React library like useState, useReducer, useConetxt \nand redux. Thanks to the vast &amp; growing React community.</p>\n<p>This particular blog talks about useReducer &amp; Redux. One is a hook \nand the other is a state management library. Their definitions, use cases, code samples and when to choose what for efficient state management.</p>\n<h4>The useReducer hook</h4>\n<p><code>useReducer</code> is a hook used for state management. Typically, a React component can have the logic used to determine UI changes. \nThe state management logic, however, is a different issue that needs to be handled elsewhere.</p>\n<p>Otherwise, we wind up with state management \nand rendering logic mixed together, which is challenging to comprehend, maintain, and test! with the huge UI components. \nThis is where <code>useReducer</code> hook comes in handy.</p>\n<p>To separate the concerns (rendering and state management) React provides the hook <code>useReducer()</code>. \nThe hook does so by extracting the state management out of the component.</p>\n<p>The <code>useReducer</code>(reducer, initialState, init?) hook accept 3 arguments:</p>\n<ul>\n <li>Reducer function</li>\n <li>Initial state</li>\n <li>Initializer function</li>\n</ul>\n<p>The hook then returns an array of 2 items:</p>\n<ul>\n <li>Current state</li>\n <li>Dispatch function</li>\n</ul>\n<figure><pre><code> const [state, dispatch] = useReducer(reducer, initialArg, init?) </code></pre></figure>\n<p>Let\u00e2\u0080\u0099s build a counter with the help of the <code>useReducer</code> hook.\nfollowing are features of the counter app.</p>\n<ul>\n <li>Increment counter by 1</li>\n <li>Decrement counter by 1</li>\n <li>Reset counter value to initial value</li>\n <li>Increment counter by 5</li>\n <li>Decrement counter by 5</li>\n</ul>\n<ul>\n <li><strong>initialState</strong> - It is the value the state is initialized with.</li>\n <li><strong>action object</strong> - It is an object that describes how to update the state.</li>\n <li><strong>dispatch</strong> - It is a special function that dispatches an action object</li>\n <li><strong>reducer</strong> - It is a pure function that accepts 2 parameters: the current state and an action object. Depending on the action object, the reducer function must update the state in an immutable manner, \nand return the new state.</li>\n</ul>\n<h4>Redux</h4>\n<p>On the other hand, Redux offers a comprehensive state management solution by centralising the application\u00e2\u0080\u0099s state in a single store with the help of actions \nand reducers.</p>\n<p>Redux Toolkit simplifies the process by serving as an abstraction over redux. It hides the difficult parts, ensuring a good developer experience.</p>\n<p>Let\u00e2\u0080\u0099s build the above counter with the help of Redux Toolkit.</p>\n<h4>Thumb rules to decide when to use <code>useReducer</code> or <code>Redux</code></h4>\n<h5>Prefer useReducer if we have:</h5>\n<ul>\n <li>Small to medium-sized applications with relatively simple state management needs</li>\n <li>Applications that only need to manage local state within a component or a few components</li>\n</ul>\n<h5>Prefer Redux Toolkit if we have:</h5>\n<ul>\n <li>Large-scale applications with complex state management needs. Redux is more", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "4d9999c6-80ef-4a22-bfbf-ab0e9bcfd41d": {"__data__": {"id_": "4d9999c6-80ef-4a22-bfbf-ab0e9bcfd41d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "7625525b-353c-457d-9333-c39e01ccab5d", "node_type": null, "metadata": {}, "hash": "302a561776bc271ca8602b4f2f89b4fb5759142393d5d8523621af589b227393"}}, "hash": "302a561776bc271ca8602b4f2f89b4fb5759142393d5d8523621af589b227393", "text": "Managing State<div><div><div><p>As your application grows, it helps to be more intentional about how your state is organized and how the data flows between your components. Redundant or duplicate state is a common source of bugs. In this chapter, you\u2019ll learn how to structure your state well, how to keep your state update logic maintainable, and how to share state between distant components.</p>\n<h2>Reacting to input with state <a href=\"#reacting-to-input-with-state\"></a></h2>\n<p>With React, you won\u2019t modify the UI from code directly. For example, you won\u2019t write commands like \u201cdisable the button\u201d, \u201cenable the button\u201d, \u201cshow the success message\u201d, etc. Instead, you will describe the UI you want to see for the different visual states of your component (\u201cinitial state\u201d, \u201ctyping state\u201d, \u201csuccess state\u201d), and then trigger the state changes in response to user input. This is similar to how designers think about UI.</p>\n<p>Here is a quiz form built using React. Note how it uses the <code>status</code> state variable to determine whether to enable or disable the submit button, and whether to show the success message instead.</p>\n</div><div><pre>import { useState } from 'react';\nexport default function Form() {\n const [answer, setAnswer] = useState('');\n const [error, setError] = useState(null);\n const [status, setStatus] = useState('typing');\n if (status === 'success') {\n return &lt;h1&gt;That's right!&lt;/h1&gt;\n }\n async function handleSubmit(e) {\n e.preventDefault();\n setStatus('submitting');\n try {\n await submitForm(answer);\n setStatus('success');\n } catch (err) {\n setStatus('typing');\n setError(err);\n }\n }\n function handleTextareaChange(e) {\n setAnswer(e.target.value);\n }\n return (\n &lt;&gt;\n &lt;h2&gt;City quiz&lt;/h2&gt;\n &lt;p&gt;\n In which city is there a billboard that turns air into drinkable water?\n &lt;/p&gt;\n &lt;form onSubmit={handleSubmit}&gt;\n &lt;textarea\n value={answer}\n onChange={handleTextareaChange}\n disabled={status === 'submitting'}\n /&gt;\n &lt;br /&gt;\n &lt;button disabled={\n answer.length === 0 ||\n status === 'submitting'\n }&gt;\n Submit\n &lt;/button&gt;\n {error !== null &amp;&amp;\n &lt;p className=\"Error\"&gt;\n {error.message}\n &lt;/p&gt;\n }\n &lt;/form&gt;\n &lt;/&gt;\n );\n}\nfunction submitForm(answer) {\n \n return new Promise((resolve, reject) =&gt; {\n setTimeout(() =&gt; {\n let shouldError = answer.toLowerCase() !== 'lima'\n if (shouldError) {\n reject(new Error('Good guess but a wrong answer. Try again!'));\n } else {\n resolve();\n }\n }, 1500);\n });\n}\n</pre></div><div>\n<hr />\n<h2>Choosing the state structure <a href=\"#choosing-the-state-structure\"></a></h2>\n<p>Structuring state well can make a difference between a component that is pleasant to modify and debug, and one that is a constant source of bugs. The most important principle is that state shouldn\u2019t contain redundant or duplicated information. If there\u2019s some unnecessary state, it\u2019s easy to forget to update it, and introduce bugs!</p>\n<p>For example, this form has a <strong>redundant</strong> <code>fullName</code> state variable:</p>\n</div><div><pre>import { useState } from 'react';\nexport default function Form() {\n const [firstName, setFirstName] = useState('');\n const [lastName, setLastName] = useState", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "d2875d35-9d80-4970-a984-10ad61dbc66b": {"__data__": {"id_": "d2875d35-9d80-4970-a984-10ad61dbc66b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c04ae75a-80cf-4405-a5a4-0a3cb58d750d", "node_type": null, "metadata": {}, "hash": "dfdc076e13736ccb3dcf4fad3a3da76e27ee74fbdfd18e4f6e1c478a7b60e6ce"}}, "hash": "dfdc076e13736ccb3dcf4fad3a3da76e27ee74fbdfd18e4f6e1c478a7b60e6ce", "text": "How to choose the best state management solution in React<div><div><div><p><p>IK</p></p><div><p>Iva Kop</p><p><time>3 July 2021</time> \u00b7 14 min read</p></div></div><p>State management is a fundamental challenge every developer needs to face when building a React app \u2014 and it is not a trivial one. There are many valid ways to manage state in React, and each one solves a salient set of problems.</p>\n<p>As developers, it is important not only to be aware of the different approaches, tools, and patterns, but to also understand their use cases and trade-offs.</p>\n<p>A helpful way to think about state management is in terms of the problems we solve in our projects. So, I will use a simple counter app to illustrate some relevant ways to think about state in React.</p>\n<h2>Local component state in React</h2>\n<p>The simplest way to implement the counter is to use local component state with the <code>useState</code> hook.</p>\n<pre><code>import { useState } from 'react';\nconst Counter = () =&gt; {\n const [count, setCount] = useState(0);\n const increaseCount = () =&gt; {\n setCount(count + 1);\n };\n const decreaseCount = () =&gt; {\n if (count &gt; 0) {\n setCount(count - 1);\n }\n };\n return (\n &lt;div&gt;\n &lt;h1&gt;{count}&lt;/h1&gt;\n &lt;button onClick={decreaseCount}&gt;-&lt;/button&gt;\n &lt;button onClick={increaseCount}&gt;+&lt;/button&gt;\n &lt;/div&gt;\n );\n};\nexport default Counter;\n</code></pre>\n<p>So we are done, right? Article over? Not quite.</p>\n<p>If this was a real project, it is likely that in the future, we would need more buttons and headers elsewhere in our app. And it is a good idea to make sure they all look and behave consistently, which is why we should probably turn them into reusable React components.</p>\n<h2>Component props in React</h2>\n<p>Turning our <code>Button</code> and <code>Header</code> into separate components reveals a new challenge. We need some way to communicate between them and the main <code>Counter</code> component.</p>\n<p>This is where component props come into play. For our <code>Header</code> component, we add a <code>text</code> prop. For our <code>Button</code>, we need both a <code>label</code> prop and an <code>onClick</code> callback. Our code now looks like this:</p>\n<pre><code>import { useState } from 'react';\nconst Header = ({ text }) =&gt; &lt;h1&gt;{text}&lt;/h1&gt;;\nconst Button = ({ label, onClick }) =&gt; (\n &lt;button onClick={onClick}&gt;{label}&lt;/button&gt;\n);\nconst Counter = () =&gt; {\n const [count, setCount] = useState(0);\n const increaseCount = () =&gt; {\n setCount(count + 1);\n };\n const decreaseCount = () =&gt; {\n if (count &gt; 0) {\n setCount(count - 1);\n }\n };\n return (\n &lt;div&gt;\n &lt;Header text={count} /&gt;\n &lt;Button onClick={decreaseCount} label=\"-\" /&gt;\n &lt;Button onClick={increaseCount} label=\"+\" /&gt;\n &lt;/div&gt;\n );\n};\nexport default Counter;\n</code></pre>\n<p>This looks great! But imagine the following scenario: what if we need to only display the count on our home route and have a separate route <code>/controls</code> where we display both the count and the control buttons? How should we go about this?</p>\n<h2>Routing in React</h2>", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "90359ef2-9f18-488c-a731-391fdcf1fbe9": {"__data__": {"id_": "90359ef2-9f18-488c-a731-391fdcf1fbe9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1db8ab12-0657-4974-a054-661e8ba8076e", "node_type": null, "metadata": {}, "hash": "458fb1a183a82b6d948202353c0eba1e030bbdc98fc25ae67167822c2be9de4f"}}, "hash": "458fb1a183a82b6d948202353c0eba1e030bbdc98fc25ae67167822c2be9de4f", "text": "Keeping track of the last value of state in React.js<div><div>\n <p>When working with states in React.js, there comes a time when you might need to differentiate between the current and previous <em>\u201cstate\u201d</em> of a state.</p>\n<p>For instance, you\u2019ve written an event that should only get triggered if the difference between the current and previous state matches a certain value.</p>\n<p>Check this simple example.</p>\n<div><pre><code>import { useState } from \"react\";\nexport default function App() {\n const [name, setName] = useState(\"Amit\");\n return (\n &lt;&gt;\n &lt;h1&gt;Current name: {name}&lt;/h1&gt;\n &lt;button onClick={() =&gt; setName(\"Cherika\")}&gt;Click Me!&lt;/button&gt;\n &lt;/&gt;\n );\n}\n</code></pre></div>\n<p>Here in this component, the initial state for <code>name</code> is \u201cAmit\u201d. Now, when the <em>\u201cClick Me!\u201d</em> button is clicked, the state of <code>name</code> will be <strong>\u201cCherika\u201d</strong>.</p>\n<p>As you can tell, currently, we don\u2019t have any means to check the previous state of <code>name</code> since we are keeping track of it.</p>\n<p>To fix this, we can use the <code>useRef</code> hook to create an <a href=\"https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables\">instance variable</a>. This can be used further to store the previous state every time the state of <code>name</code> is updated using the <code>useEffect</code> hook like so.</p>\n<div><pre><code>import { useState, useRef, useEffect } from \"react\";\nexport default function App() {\n const [name, setName] = useState(\"Amit\");\n const prevName = usePrevious(name);\n return (\n &lt;&gt;\n &lt;h1&gt;Current name: {name}&lt;/h1&gt;\n &lt;h1&gt;Previous name: {prevName}&lt;/h1&gt;\n &lt;button onClick={() =&gt; setName(\"Cherika\")}&gt;Click Me!&lt;/button&gt;\n &lt;/&gt;\n );\n}\nfunction usePrevious(value) {\n const ref = useRef();\n useEffect(() =&gt; {\n ref.current = value;\n });\n \n return ref.current;\n}\n</code></pre></div>\n<p>As you can tell, we can create a custom hook called <code>usePrevious</code> which holds the logic to keep the previous state since the <em>\u201cref\u201d</em> object here is a generic container whose <code>current</code> property is mutable and can hold any value, similar to an instance property on a class.</p>\n<p>We can mutate the <code>current</code> property of <em>\u201cref\u201d</em> inside the <code>useEffect</code> hook with the new state (which would still be the previous state when the button is clicked). And hence, we can keep track of the previous and current states.</p>\n<p>Here\u2019s putting it all together!</p>\n </div><p>\n Beep! Beep! I'm also running a <a href=\"https://www.youtube.com/c/AmitMerchant?sub_confirmation=1\">YouTube channel</a> which I hope you're going to love!\n \n </p>", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "ea41e27f-c360-4de6-acfe-95aef8d9c52a": {"__data__": {"id_": "ea41e27f-c360-4de6-acfe-95aef8d9c52a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "0a2e85b1-938c-4a76-bb05-ad8ae47465ed", "node_type": null, "metadata": {}, "hash": "125a20ccea0a31861620243a042baaeebe0487c86ca3895e99c9405b59238066"}}, "hash": "125a20ccea0a31861620243a042baaeebe0487c86ca3895e99c9405b59238066", "text": "ReactJS Software Design Pattern: State Machine<div><div><article><div><div><figure><a href=\"https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F062687f1-5d56-4f46-901a-7adf94312288_417x360.jpeg\"><div></div></a></figure></div><p>One of things I like about ReactJS is that it\u2019s unopinionated - Apart from some anti-patterns, there isn\u2019t really a right or wrong way to do things. While this grants you a lot of freedom, things can get messy fast if you don\u2019t find a good way to structure your work.</p><p>I\u2019m using ReactJS to develop the front-end for <a href=\"https://zkpay.me/\">ZKPay</a>. I was finding it increasingly difficult to manage the application because of how many different states it could be in (e.g. SDK not initialized, SDK initialized, user not logged in, user logged in, no user associated with address, not synced to rollup, synced to rollup, awaiting user signature, signature rejected, signature accepted\u2026 etc).</p><p>I\u2019m not an expert at ReactJS or software design patterns, I just wanted to pick something I knew how to use that would do the job.</p><p>I learned how to implement state machines during my game development days. I used it quite frequently, especially when implementing AI.</p><p>I love this pattern because it breaks up a complex apps into smaller, easier to manage actions. Not only does this make debugging a whole lot easier, it also improves long term velocity by allowing actions to be added, rearranged or split up when the requirements of your app change or get more complicated.</p><p>Alright, enough with the long-winded intro. Let\u2019s get into implementation details\u2026</p><p>To implement the state machine, you need 2 things:</p><ol><li><p>State definitions.</p></li><li><p>The \u201ccore\u201d state machine function.</p></li></ol><p>This is just a list of states. For each state which your app can be in, add a definition. I like to keep things simple and use a constant:</p><pre><code>const State = {\n RESET : 0,\n INIT : 1,\n ENTER_DEPOSIT_DETAILS: 2,\n CREATE_PROOF : 3,\n ALLOW_SIG_PENDING : 4,\n ALLOW_SIG_REJECTED : 5,\n DEPOSIT_SIG_PENDING : 6,\n DEPOSIT_SIG_REJECTED : 7,\n SEND_DEPOSIT : 8,\n COMPLETE : 9,\n ERROR_WAITING_FUNDS : 10\n};</code></pre><p>This is where all the magic happens.</p><p>I use a combination of React\u2019s useEffect, a state variable and a case/switch statement to implement this:</p><pre><code>const [state, setState] = useState(State.INIT);\nuseEffect(() =&gt; {\n switch (state) {\n case State.RESET:\n {\n // Do RESET things.\n }\n break;\n case State.INIT:\n {\n // Do INIT things.\n \n // When INIT is complete:\n setState(State.ENTER_DEPOSIT_DETAILS);\n }\n break;\n case State.ENTER_DEPOSIT_DETAILS:\n {\n // Wait for user to enter form details.\n }\n break;\n case State.CREATE_PROOF:\n {\n // Create Aztec proof.\n }\n break;\n // Etc....\n }\n}, [state]); // Run this function every time the state changes</code></pre><p>A few implementation tips:</p><ul><li><p>The state machine will manage state for the component it\u2019s implemented in and all child components. It makes the most sense to implement a state machine in some", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "cf030f34-72d5-4332-91e1-81fac4ebaeb0": {"__data__": {"id_": "cf030f34-72d5-4332-91e1-81fac4ebaeb0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "8a3a914b-9f97-4f92-8571-4c7bbc9b0364", "node_type": null, "metadata": {}, "hash": "92253d5ecfd9c1fafdf0353df68eaf9a702e029a9f81b2f6d3699cf8aa40b868"}}, "hash": "92253d5ecfd9c1fafdf0353df68eaf9a702e029a9f81b2f6d3699cf8aa40b868", "text": "A Contemporary Guide on React State Patterns in 2021<div><div>\n <article>\n\t \n <div>\n \n \n \n<h4>Since the initial release of React in 2013, Facebook has rolled out a robust collection of tools to help developers with some of the minutiae of the web application development process, allowing them to focus on what matters most.</h4>\n<p>Despite React\u2019s many capabilities and widespread adoption among developers, I\u2019ve discovered that many of us face the same question: How can we handle complicated states with React?\u00a0</p>\n<p>You may like: <strong><a href=\"https://mushfiqweb.com/crud-using-react-hooks-and-context-api/\">Crud Using React Hooks and Context API</a></strong></p>\n<p>This post will look at what state is, how to arrange it, and alternative patterns to use as our applications become more complicated.</p>\n<h3>Understanding React State</h3>\n<p>React may be thought of as a blueprint in its most basic form. Your application will appear in a specific way depending on the status. React prefers declarative over imperative programming, a fancy way of stating that you express what you want to happen rather than the processes to get there. As a result, appropriately managing the state becomes critical, as the state determines how your program will act.</p>\n<div><figure></figure></div>\n<h3>React State in action</h3>\n<p>Before we get started, it\u2019s a good idea to define what a state is. State, in my opinion, is a set of changeable values that change over time and directly impact component behavior.</p>\n<p>Props and state are extremely similar, except state may be updated inside the context of where it is created, whereas props received cannot be edited without supplying a callback function.</p>\n<p>Take a look at this:</p>\n<pre><code>const UserList = () =&gt; {\n const [users, setUsers] = useState([])\n useEffect(() =&gt; {\n const getUsers = async () =&gt; {\n const response = await fetch(\"https://myuserapi.com/users\")\n const users = await response.json()\n setUsers(users)\n }\n getUsers()\n }, [])\n if (users.length &lt; 1) return null;\n return &lt;ul&gt;\n {users.map(user =&gt; &lt;li&gt;{user.name}&lt;/li&gt;)}\n &lt;/ul&gt;\n}</code></pre>\n<p>When the component mounts, we fetch users from an API and update the users\u2019 array after receiving a response. To keep the example simple, we use the na\u00efve assumption that the call will always be successful.</p>\n<p>The state is being used to render list items with the user\u2019s name, and it will return null if the array contains no users. The state varies over time and is used to control component behavior directly.</p>\n<p>It\u2019s also worth noting that we\u2019re using React\u2019s built-in state management technique, the <code>useState</code> Hook. You may need to utilize React\u2019s built-in Hook to handle your state, depending on the intricacy of your application and state management.</p>\n<p>The built-in state management mechanism isn\u2019t always enough, as seen by the number of state management alternatives for React. It\u2019s time to look at some of the reasons for this.</p>\n<h3>Understanding prop drilling</h3>\n<p>Let\u2019s have a look at a little more complicated App. As your project grows, you\u2019ll be pushed to add many levels of components to segregate concerns and/or improve readability. The issue arises when the state is required by various components located at various levels of the tree.</p>\n<figure></figure>\n<p>If we wanted to provide user data to both the <code>UserMenu</code> and <code>Profile</code> components, we had to put the state in <code>App</code> where it could be propagated down to each component that needed it. That means we\u2019ll feed it via components like Dashboard and Settings", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "88966786-4f42-493c-9516-b997336c5036": {"__data__": {"id_": "88966786-4f42-493c-9516-b997336c5036", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "3081f397-bfc3-4aee-933f-294d67337814", "node_type": null, "metadata": {}, "hash": "3e12e6dea2bf55c3acb7b32434c3dfb0163f9caed76e8afa3ef5b93f90a4b5f2"}}, "hash": "3e12e6dea2bf55c3acb7b32434c3dfb0163f9caed76e8afa3ef5b93f90a4b5f2", "text": "Mastering React State Management: Tips & Tricks<div><div><figure></figure><p>Hello, Welcome to Tech Artifacts. I hope you are doing well.</p><p>In this blog, we are going to cover the topic of React State Management. State management is the process of maintaining and updating the data or state of a client-side application over time.</p><p>If you are new to React, I would recommend you first take a look at the below blogs \u2013</p><ol><li><a href=\"https://techartifacts.com/introduction-to-react/\">Introduction to React</a></li><li><a href=\"https://techartifacts.com/react-components-and-props/\">React \u2013 Components and props</a></li></ol><div><nav><ul><li><a href=\"https://techartifacts.com/react-state-management/#State_Management\">State Management</a></li><li><a href=\"https://techartifacts.com/react-state-management/#Importance_of_Statement_Management_in_React\">Importance of Statement Management in React</a><ul><li><a href=\"https://techartifacts.com/react-state-management/#Improves_Consistency\">Improves Consistency</a></li><li><a href=\"https://techartifacts.com/react-state-management/#Improves_Maintenance_and_Scalability\">Improves Maintenance and Scalability</a></li><li><a href=\"https://techartifacts.com/react-state-management/#Improves_Application_Performance\">Improves Application Performance</a></li></ul></li><li><a href=\"https://techartifacts.com/react-state-management/#Example_of_Statement_Management_in_React\">Example of Statement Management in React</a></li><li><a href=\"https://techartifacts.com/react-state-management/#useState_Hook\">\u201cuseState\u201d Hook</a></li><li><a href=\"https://techartifacts.com/react-state-management/#Other_State_Management_Techniques\">Other State Management Techniques</a></li><li><a href=\"https://techartifacts.com/react-state-management/#Conclusion\">Conclusion</a></li></ul></nav></div><p>Let\u2019s first understand what is state management.</p><p>In client-side applications, state refers to the data that is used by the application to render its user interface (UI). This data can include information such as user input, API responses, and other data that changes dynamically over time.</p><p>State management is an important aspect of building client-side applications. It ensures that the UI remains up-to-date and consistent with the change in the underlying data.</p><p>Without proper state management, it can be challenging to keep track of the data used by an application. The state also helps to ensure that the UI remains in sync with this data.</p><h2>Importance of Statement Management in React</h2><h3>Improves Consistency</h3><p>In React, State Management enables developers to manage the data used to render the user interface. It also helps to keep track of the changes made to this data over time. This helps to prevent inconsistencies in the UI and to ensure that the application remains in a consistent state.</p><h3>Improves Maintenance and Scalability</h3><p>State management also makes it easier to maintain and scale applications. It provides a centralized approach to managing the state of the application. This allows developers to manage the state of the application in a more organized and predictable manner. To make changes to the state without affecting other parts of the application.</p><h3>Improves Application Performance</h3><p>State management can also help to improve performance by reducing the amount of data that needs to be re-rendered when changes are made to the state. By only updating the components that are affected by the changes to the state, React can optimize the performance of the application and provide a more efficient user experience.</p><h2>Example of Statement Management in React</h2><p>The importance of state management in React can be best explained through an example.</p><p>Consider a simple React application that displays a list of to-do items. Each item in the list has a Title, a Description, and a Status that can be either \u201ccomplete\u201d or \u201cincomplete.\u201d</p><p>Without state management, you would have to manage the state of each to-do item individually in the component that", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "ec578717-d565-448e-9467-5a15997049d6": {"__data__": {"id_": "ec578717-d565-448e-9467-5a15997049d6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "e1010cad-8da7-40ed-9e16-50d30b02986d", "node_type": null, "metadata": {}, "hash": "8376a8f11f49540490576e7226beb3f3a62711dcc25693010678dc3c6af22a39"}}, "hash": "8376a8f11f49540490576e7226beb3f3a62711dcc25693010678dc3c6af22a39", "text": "Introduction to React Hooks<div><div>\n \n <main>\n <div>\n <article>\n <header>\n <div>\n <p><a href=\"/ksowah\"></a>\n </p>\n \n </div>\n </header>\n <div>\n <p>Welcome back, readers, to another blog where I attempt to demystify and clarify a specific web development topic. This blog post will concentrate on defining React Hooks and demonstrating how to use them in your React application.</p>\n<p>React is a JavaScript library that makes it simple to construct rich user interfaces and single page applications. You develop your user interface using components that you generate in React. State and props are two of the most essential React component features. A React component's state is an object that controls how the component renders and functions. Only class-based components could hold state prior to the invention of hooks. On the other hand, using props enables us to communicate with our components. The official <a href=\"https://reactjs.org/\">website</a> is definitely a good place to start if you want to learn more about React.</p>\n<p>With the introduction of hooks in version 16.8 of the React library, you may now use state and other React capabilities without the need for classes. In other words, a functional component allows for the addition and modification of state. You can utilize a number of React hooks, but for the sake of this article, I'll concentrate on <code>useState</code> which is one of the most crucial and widely used hooks.</p>\n<p><strong>useState Hook</strong><br />\nThe <code>useState</code> hook enables us to use and control state inside a functional component. The <code>useState</code> hook is used in the basic functional component shown below as an example.</p>\n<p><a href=\"https://res.cloudinary.com/practicaldev/image/fetch/s--D0K7dUW4--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/g510x5ykfms8c1f05vb5.png\"></a></p>\n<p>This component is made up of an <code>input</code> tag and a <code>h1</code> tag. The information you type in the <code>input</code> tag is shown in the <code>h1</code> tag as you type.</p>\n<p>The <code>useState</code> hook from the React library is imported in line one of the code above. However, line 5 of the code is the most crucial one. We start using our imported <code>useState</code> hook here. In essence, the <code>useState</code> hook is a function that takes an initial state. I passed an empty string in our example. A pair of values are returned in an array by the <code>useState</code> hook.</p>\n<p>The array's first value is the state as it is at the moment, and its second value is a function that lets you modify or update the state. The two values are extracted from the array and stored in separate constants using array destructuring in the code above.</p>\n<p>In contrast to object destructuring, array destructuring allows you to use any name for your constants, but order is crucial. When naming your function, start with <code>set</code>, you'll often use the format shown below, followed by the name of the constant you used to store the current state. as in \"<code>setName</code>,\" \"<code>setAge</code>,\" \"<code>setColor</code>,\" etc.</p>\n<p>We make use of the <code>setName</code> method in the <code>onChange</code> event on line 10. The <code>setName</code> function receives the value of the input tag, which updates the state in this case, the <code>name</code> constant.</p>\n<p>I would like to draw your attention to the fact that the <code>useState</code> hook can be used many times within one functional component. See image below \ud83d\udc47</p>\n<p><a href=\"https://res.cloudinary.com/practicaldev/image/fetch/s", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "bd2bb196-08f9-4098-b561-c37224e8be47": {"__data__": {"id_": "bd2bb196-08f9-4098-b561-c37224e8be47", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "b166836b-d0ae-4119-b667-7b80d6666703", "node_type": null, "metadata": {}, "hash": "f9feb6c7daf16e65eab8d76d8d0a997a847516bd7f3c9592b1508d18fa49a2e0"}}, "hash": "f9feb6c7daf16e65eab8d76d8d0a997a847516bd7f3c9592b1508d18fa49a2e0", "text": "The Suspense is Killing Me: Part 2<div><section><p>I have to admit, I didn\u2019t intend to put a year between two parts to create\u2026 suspense. Yet, here we are. The past year was full of updates and most importantly, <a href=\"https://reactjs.org/blog/2022/03/29/react-v18.html\">React 18 is shipped</a> with some of the features I mentioned in the previous post.</p>\n<p>Let\u2019s quickly go over some of the most important things that happened in the last year and what got shipped.</p>\n<h2><a href=\"#what-happened-in-the-meantime\"></a>What happened in the meantime</h2>\n<h3><a href=\"#react-18-working-group\"></a>React 18 Working Group</h3>\n<p>React team created this <a href=\"https://github.com/reactwg/react-18/discussions\">discussion board</a> to announce updates and gather feedback from community leaders. It provided a lot of in-depth information, and the feedback received shaped some APIs to have better ergonomics and support unforeseen use cases.</p>\n<h3><a href=\"#react-18-release\"></a>React 18 Release</h3>\n<p>Around a year after the announcement of the working group, and after a few prereleases, <a href=\"https://reactjs.org/blog/2022/03/29/react-v18.html\">React 18 was released</a> as stable. It came with important features such as streaming SSR with Suspense, transitions API, automatic batching, and a few new hooks.</p>\n<h3><a href=\"#a-new-react-labs-post\"></a>A new React Labs post</h3>\n<p>React Labs was announced before my last post, providing architectural deep dives in video format. It didn\u2019t receive any updates, but a blog post featuring active exploration areas <a href=\"https://reactjs.org/blog/2022/06/15/react-labs-what-we-have-been-working-on-june-2022.html\">recently come up</a> in React blog.</p>\n<hr />\n<p>With all these, we now have a more complete vision of the React team and what\u2019s coming next. In the first part, I mentioned some of the most exciting features that I expected to land with React 18. Some of them actually landed, others were pushed back, and there were features that I didn\u2019t even know about. So, first let\u2019s go over the important features that are new in React 18.</p>\n<h2><a href=\"#whats-new-in-react-18\"></a>What\u2019s new in React 18</h2>\n<h3><a href=\"#no-more-concurrent-mode\"></a>No more Concurrent Mode</h3>\n<p>The now removed React docs about concurrent features mentioned three modes: Legacy, Blocking, and Concurrent. This distinction didn\u2019t land in React 18, in favor of <a href=\"https://github.com/reactwg/react-18/discussions/64\">enabling concurrency only in subtrees</a> that use those features, for backward compatibility. If you don\u2019t use concurrent features, your React app will work and behave as before.</p>\n<h3><a href=\"#transitions\"></a>Transitions</h3>\n<p>This is one of the aforementioned concurrent features. While state updates will keep working the same as before, you can mark a state update as a <a href=\"https://github.com/reactwg/react-18/discussions/41\">\u201ctransition\u201d</a>, by wrapping it in a <code>startTransition</code> call to let React know that it is not an urgent update and more urgent updates are allowed to interrupt it. A non-urgent update is rendered concurrently, so, as a bonus, it enables time-slicing. You can use the hook version (<code>useTransition</code>) to show the user that an update is pending, or use the <code>useDeferredValue</code> hook to achieve a similar effect when you have no control over setting the state. (Transitions are opt-in for now but they may become the", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "20ca9fd8-70c0-49ef-9316-35f2015df506": {"__data__": {"id_": "20ca9fd8-70c0-49ef-9316-35f2015df506", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "966c75da-9f72-4e6c-8885-87c6c22ea382", "node_type": null, "metadata": {}, "hash": "c8b3d4e5d29cd5ce35274aae41dd7332561eb486b0f4a8373729c3e91a8eb75b"}}, "hash": "c8b3d4e5d29cd5ce35274aae41dd7332561eb486b0f4a8373729c3e91a8eb75b", "text": "Why State Management is Important For React Apps<div><div><article><div><p></p><h2>Manage your data well enough to make your apps efficient</h2><p></p><figure><figcaption>Photo by <a href=\"https://unsplash.com/@7bbbailey?utm_source=medium&amp;utm_medium=referral\">Barth Bailey</a> on <a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><p>When it comes to software engineering it\u2019s all about the data. Databases store the data, server-side technologies like Java, .NET, etc move data around and from server to client, Frontend frameworks use that data and show that to the user. All the tools and frameworks that we use to make\u2026</p></div></article></div>", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}}, "docstore/ref_doc_info": {"7c3ed5c2-22b2-4215-b065-4710571c590d": {"node_ids": ["671eab7f-ec86-43dc-8549-b0c4f1460082"], "metadata": {}}, "b485632a-551d-40c8-9db5-649e7612d816": {"node_ids": ["48b37e0f-ebbb-469d-abcc-17812f7dedc2"], "metadata": {}}, "6c03bb40-ca0a-449c-98f7-bf0ef92eebcd": {"node_ids": ["8d90a360-0f4b-406b-af45-04c1f672a033"], "metadata": {}}, "396c8c2d-d8a6-4232-b3bb-623b78c7dbb2": {"node_ids": ["c94ba9b2-171c-4436-bbbe-5648fbfa0976"], "metadata": {}}, "9f3b69a8-a8f3-44c2-9285-5eacc5048966": {"node_ids": ["db78cd10-fd01-4a7a-9df1-4e4a7c8678ea"], "metadata": {}}, "ff5df263-c393-4bf7-afda-2fe76ae0b014": {"node_ids": ["bc324e66-991f-465a-92a4-8d689147f56c"], "metadata": {}}, "d6ef9e51-de90-4990-8182-c0dbef8a7bb5": {"node_ids": ["fa26c9aa-8c87-4202-8611-ba2a2aec8392"], "metadata": {}}, "026edf98-f7cd-4def-84d0-af4d6bfa69b4": {"node_ids": ["d836a08a-b98f-487d-9429-db17e66ad00e"], "metadata": {}}, "a5dbee3c-4a79-4543-b2b1-908c92b4a907": {"node_ids": ["d29dbcbe-e9ca-4456-8d00-d5440ff11174"], "metadata": {}}, "12cb0b3e-3bbc-4452-8c83-0bc8dac09943": {"node_ids": ["5286542b-4c20-44b6-be60-a7008d068599"], "metadata": {}}, "ca484c06-c775-4158-b7b3-00022c369c18": {"node_ids": ["02c8c866-af01-46c8-9bde-e3bfaf51cbad"], "metadata": {}}, "7625525b-353c-457d-9333-c39e01ccab5d": {"node_ids": ["4d9999c6-80ef-4a22-bfbf-ab0e9bcfd41d"], "metadata": {}}, "c04ae75a-80cf-4405-a5a4-0a3cb58d750d": {"node_ids": ["d2875d35-9d80-4970-a984-10ad61dbc66b"], "metadata": {}}, "1db8ab12-0657-4974-a054-661e8ba8076e": {"node_ids": ["90359ef2-9f18-488c-a731-391fdcf1fbe9"], "metadata": {}}, "0a2e85b1-938c-4a76-bb05-ad8ae47465ed": {"node_ids": ["ea41e27f-c360-4de6-acfe-95aef8d9c52a"], "metadata": {}}, "8a3a914b-9f97-4f92-8571-4c7bbc9b0364": {"node_ids": ["cf030f34-72d5-4332-91e1-81fac4ebaeb0"], "metadata": {}}, "3081f397-bfc3-4aee-933f-294d67337814": {"node_ids": ["88966786-4f42-493c-9516-b997336c5036"], "metadata": {}}, "e1010cad-8da7-40ed-9e16-50d30b02986d": {"node_ids": ["ec578717-d565-448e-9467-5a15997049d6"], "metadata": {}}, "b166836b-d0ae-4119-b667-7b80d6666703": {"node_ids": ["bd2bb196-08f9-4098-b561-c37224e8be47"], "metadata": {}}, "966c75da-9f72-4e6c-8885-87c6c22ea382": {"node_ids": ["20ca9fd8-70c0-49ef-9316-35f2015df506"], "metadata": {}}}}