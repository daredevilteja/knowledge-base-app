Share state using custom hooks<div><div>
 <p>Many articles have been written about React state management strategies for React, and yes, this is yet another one of them. But rather than talking about a new library and how everyone should adopt it, I want to talk about two different philosophical approach to state: centralised vs decentralised.</p>
<h2>
 <a href="#the-decentralised-state-paradigm">
 </a>
 The decentralised state paradigm
</h2>
<p>Decentralised state has been the battery-included solution since the first version of React. Class components can edit local state to trigger a re-render, and functional components can accomplish the same with the <code>useState</code> hook. </p>
<p>Local state is very intuitive to manipulate because it sits near the component that uses it for display and side effects, it's allocated when needed, and disappears when the component is unmounted.</p>
<h2>
 <a href="#the-centralised-state-paradigm">
 </a>
 The centralised state paradigm
</h2>
<p>Keeping all mutable state in one place is an approach championed by Elm, ClojureScript and Redux: a single data structure (usually a tree) contains all the state needed to render your React application. When a branch of that tree changes state, the relevant components in your React hierarchy re-render displaying the new information.</p>
<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--CO4u-rov--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/jh6fvhqttth686rqcml8.png"></a></p>
<p>A single point of reference for the entire app state is a very neat idea and feels like a natural evolution on top of React itself: React abstracts DOM changes with components, the app state abstracts component changes with a big JSON value.</p>
<p>Since all changes are represented with data, the logic that transitions the app through different states is very easy to express and to test: it's just a function <code>f(currentState, event) =&gt; newState</code>. It's also easy to generate many valid UI screens by mocking the app state.</p>
<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--n4Pi9Qwx--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vpnb4kvtblrwjkhsw9u7.png"></a><br />
<em><a href="https://github.com/frankiesardo/speccards">speccards</a> generates random valid UI states based on a spec</em></p>
<h2>
 <a href="#problems-with-decentralised-state">
 </a>
 Problems with decentralised state
</h2>
<p>Local state becomes problematic when two components need to watch and act on the same state. Think about a simple currency converter where the user can edit either currency text input.</p>
<p>In this case the naive solution is to "lift the state up" to the closest parent and give all children callback functions to manipulate the state. </p>
<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--avzR7JC6--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/sc4r26cibamtwqw1982l.png"></a><br />
 <em><a href="https://reactjs.org/docs/lifting-state-up.html">Lifting State Up</a> in vanilla React</em></p>
<p>This rarely scales for bigger applications, so something like <a href="https://recoiljs.org/">Recoil</a> might