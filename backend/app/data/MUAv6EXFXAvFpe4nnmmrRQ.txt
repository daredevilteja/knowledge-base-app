React Gets First Class Support for Async/Await — Yay or Meh?<div><div><p></p><h2>A look into the React RFC Draft proposal support for data loading</h2><p></p><figure><figcaption>Image by Author</figcaption></figure><p>The first cornerstone of React’s first-class support for Async/Await started when the team introduced <code>Suspense</code> on React <code>16.6</code>. Back then, there was still no concurrent mode and its functionality was limited. The suspended component would render and just be hidden on the DOM. It was known as <code>Legacy Suspense</code>.</p><p>The <code>Suspense</code> was to become an important mechanism on which all the other APIs would rely.</p><p>When concurrent mode landed, the <code>Suspense</code> API was enhanced:</p><ul><li>The execution of the React Component is “paused”. The <code>Element</code> is not mounted until the <code>ComponentThatSuspends</code> is resolved.</li><li>Effects/Lifecycle are fired properly.</li></ul><p>As of today, lazy loading components is the only use case supported by <code>Suspense</code>. The React team has been spending a long time figuring out how to blend data loading with <code>Suspense</code>. In this published RFC Draft, we can finally see how they plan to build it.</p><h2>Suspense for Data Fetching</h2><p>The approach the React team is taking is quite conventional, but with a twist.</p><p>They have chosen to implement this feature in two flavors:</p><ul><li>React Client: by introducing a <code>use</code> hook</li><li>React Server Components: supporting the native <code>async/await</code> Es7 syntax.</li></ul><h2>The use hook</h2><p>This hook is as controversial as its name. They have chosen this particular name in an attempt to differentiate it from the rest. Why? Because this hook is different: <strong>it can run conditionally</strong>.</p><p>This alone breaks the whole conception of hooks that we have learned over the past years. It is quite remarkable how the React team has baked that idea into our heads. There even was a famous post from Dan Abramov explaining why in detail (<a href="https://overreacted.io/why-do-hooks-rely-on-call-order/">link here</a>).</p><p>How can the <code>use</code> hook be conditionally invoked? Because simplified, it just throws a <code>Promise</code> that is caught by the nearest <code>Suspense</code> parent.</p><figure></figure><p>What is the caveat of this approach? Unlike <code>async/await</code>, the React Component will not resume where it left off. Instead, the suspended component will be re-rendered. This is a side-effect of React components being idempotent, how ironic.</p><p>Let’s an example of the new <code>use</code> hook in action:</p><figure></figure><p>The above code looks simple and easy to reason about. There is only one catch. The <code>&lt;Test /&gt;</code> component will re-render endlessly.</p><p>Why? As seen previously, the rendered is “paused” by throwing a promise-like exception. The whole component will be re-rendered when the promise is resolved. That means, that the <code>fetchData</code> method will be invoked again which will result in another re-render and so on.</p><p>What are the possible fixes?</p><ul><li>create a cache mechanism for the resolved promises.</li><li>wait and use the <code>cache</code> API that the React team is working on. The ergonomics will be something like <code>use(cache(fetchData))</code> adding more complexity to the mix.</li></ul><p>The <code>cache</code> API has yet to see a draft. The feature would be landing most likely after the