Understanding Suspense-ful coding in React<div><div><p><strong>TLDR; <code>&lt;Suspense&gt;</code> is cool and a useful way to handle async loads in your React apps, but it has some tricky gotchas about data flow and caching if you try to use it with bare <code>Promise</code>s. An easy way to solve this and use Suspense today is <a href="https://github.com/zackdotcomputer/suspension">suspension</a>.</strong></p>
<hr />
<p>I've been working this week on a little webapp to practice integrating React apps with Firebase backends. As part of this project, I pulled in <a href="https://github.com/FirebaseExtended/reactfire">reactfire</a>, which is the first module I've used that had first class support for the new React <code>&lt;Suspense&gt;</code> component. I'd heard about this component before but it was finally time to do a deep dive into what it was, how it worked, and how I could integrate it more deeply into my React apps going forward.</p>
<h2>What is Suspense?</h2>
<p>Suspense was the first component from React's <a href="https://reactjs.org/docs/concurrent-mode-suspense.html">experimental Concurrent mode</a> to be merged into the non-experimental release (way back in 16.6). Suspense's job is to detect the need for an async load and render a fallback loading UI.</p>
<pre><code>function CalendarApp() {
 const [viewedDay, setViewedDay] = useState(new Date());
 // Assuming that CalendarDayView is ready to work with Suspense,
 // this renders your loading spinner while today's data is loading.
 return (&lt;main&gt;
 &lt;Suspense fallback={&lt;LoadingSpinner /&gt;}&gt;
 &lt;CalendarDayView date={viewedDay} /&gt;
 &lt;/Suspense&gt;
 &lt;/main&gt;);
}
</code></pre>
<p>If that was all it did, it would be basically syntactic sugar over the tried-and-true pattern of <code>if (callStatus === "loading") { return &lt;LoadingSpinner /&gt;; }</code>. But Suspense has a superpower that very few people are talking about, but to understand it we have to first understand how this component works.</p>
<h2>How does Suspense work?</h2>
<p>Suspense works by mildly abusing the <code>throw</code> statement. A component or hook that wants to indicate that it is still loading and needs more time should <code>throw</code> a <code>Promise</code> that will resolve when the component is ready for its render to be reattempted.</p>
<pre><code>function CalendarDayView({ date }) {
 // Let's imagine our ORM has a cache of days' agendas we can check
 const cacheResult = calendarDB.cachedValue({ date });
 // To hook into Suspense, we recognize if we need to load and
 // throw a Promise that resolves when we're ready to try again.
 if (!cacheResult) {
 const loadingPromise = calendarDB.load({ date });
 loadingPromise.then((result) =&gt; {
 calendarDB.cache({ date, value: result });
 });
 throw loadingPromise;
 }
 // Otherwise do the render
 return (
 &lt;h1&gt;Calendar for {cacheResult.dayString}&lt;/h1&gt;
 // ... and so on
 );
}
</code></pre>
<p>When we <code>throw</code> a Promise like this, React climbs the virtual DOM to find the nearest <code>&lt;Suspense&gt;</code> component and hands it the Promise.</p>
<p><strong>This removes the whole tree under that Suspense from the rendered DOM and replaces it with the <code>fallback</code>.</strong></p>
<p>This is how Suspense can give us superpowers. Because the <code>throw</code> interrupts our component's render process, we are guaranteed that if we get past it we are not loading