Understanding State Management Solutions<div><div>
 <p>
 </p>
 
 </div><div>
 <blockquote>
<p>As your application grows, it helps to be more intentional about how your state is organized and how the data flows between your components. A redundant or duplicate state is a common source of bugs.</p>
</blockquote>
<p>When it comes to thinking about State Management solutions, the first example that comes to mind is User authentication and authorization. Choosing a set of technologies to solve this is not an easy task and could even change from case to case subject to your business needs. You need to ask yourself how will these technologies make it easier to:</p>
<ul>
<li>Navigate your Users through authentication</li>
<li>Manage UI changes as Users' state changes</li>
<li>Share state between components (regardless if you'll prop drilling or not)</li>
<li>Create performant applications at scale</li>
</ul>
<p>To understand the problems that a good state management solution solves, this article provides an example based on the following technologies:</p>
<ul>
<li>
<strong>Supabase Authentication &amp;&amp; Database</strong>: authentication with Row Level Security synced with a full Postgres database and OOTB (out of the box) APIs to interact with your Supabase instance.</li>
<li>
<strong>TanStack Query v4</strong> <em>(hereafter referred to as React Query)</em>: declarative asynchronous state management solution for modern applications. </li>
</ul>
<h2>
 <a href="#before-anything-react-query-is-not-a-data-fetching-library">
 </a>
 Before anything, React Query is NOT a data fetching library
</h2>
<p>Let's touch base on a common misconception: React Query is NOT a data fetching library. Even if it <em>does</em> simplify data fetching in React applications, it does not fetch any data at all on its own. Whenever you introduce React Query in your application, you'll quickly realize that you need an actual data fetching library to get the data before anything happens, such as <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>, <a href="https://axios-http.com/">Axios</a>, etc. More on this can be found on Dominik's <a href="https://tkdodo.eu/blog/react-query-as-a-state-manager">React Query as a State Manager</a>.</p>
<h2>
 <a href="#storing-user-data">
 </a>
 Storing User Data
</h2>
<p>Creating a Supabase instance (or project) is as easy as <a href="https://app.supabase.com/">signing up</a> and following the steps until you reach your instance's dashboard. Once there, here are a couple of things you'll want to configure in <strong>Authentication &gt; Configuration &gt; Settings</strong>:</p>
<ul>
<li>User Signups: enabled (for Guest authentication)</li>
<li>Redirect URLs: the base domain for both your development and production URLs</li>
<li>Auth Providers: Email (for Guest authentication) &amp;&amp; GitHub</li>
</ul>
<h3>
 <a href="#guest-authentication">
 </a>
 Guest Authentication
</h3>
<p>In some cases, you might want to reduce the friction between your Users and your application resources by enabling <em>Guest Authentication</em>. </p>
<p>Ask your user for an identifier key value (their name would be just fine), and append a default email address and password. Disclaimer: for this to be an acceptable or safe solution, you will want to restrict full access to your application with anything other than an email/password combination such as a Social Provider (like GitHub), otherwise, adjustments would have to be considered.<br />
</p>
<div>
<pre><code>const signInGuest = async () =&gt; {
 const { user, session, error } = await supabase.auth.signUp({
 email: `${name}-${nanoid(10