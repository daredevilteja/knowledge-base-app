Introduction to React v18 Suspense and Render-as-You-Fetch approach<div><div><h2>React v18 features: Suspense</h2><p></p><h2>In this lesson, we are going to explore React’s new ”Suspense” API released in v18 and how concurrent features work.</h2><p></p><figure><figcaption>(source: <a href="https://unsplash.com/photos/jf1EomjlQi0"><strong>unsplash.com</strong></a>)</figcaption></figure><p>Loading data has always been a hassle in web development, whether you are working with React or any other framework. The problem arises when you have multiple API calls to fetch data and you need to show the user the loading state of the application. Let’s take a small example.</p><figure><figcaption>(source: <a href="https://codesandbox.io/s/react-suspense-normal-fetch-parallel-5kiiuh">https://codesandbox.io/s/react-suspense-normal-fetch-parallel-5kiiuh</a>)</figcaption></figure><p>In the example above, we have a small application in which we display the User and Post data by making external Rest API calls individually from the components responsible to display them which are <code>User</code> and <code>Post</code>.</p><p>We have added a manual delay in the API response but in the real world, this can be a pretty usual behavior. The <code>/users/</code> call resolves in <code>5s</code> while <code>/posts/</code> call resolves in <code>3s</code>, a little earlier than the <code>/users</code> call. Until the request resolves, they display a <code>Loading...</code> message on the screen.</p><p>Since these requests run in parallel, you can’t really guess which one will resolve first. In our case, we see <code>Post</code> earlier than the <code>User</code> and perhaps that would not be a very good experience. If we have a complex application with multiple parallel requests, we would see different parts of the application load in random order. The more natural behavior for an application is to render things from top to bottom.</p><p>To fix this issue, we can use a <strong>waterfall</strong> pattern. What we could do is to nest the <code>Post</code> component inside <code>User</code> such that <code>Post</code> only appears when <code>User</code> is finished loading its data. It would look like the below.</p><figure><figcaption>(source: <a href="https://codesandbox.io/s/react-suspense-normal-fetch-waterfall-vyswny">https://codesandbox.io/s/react-suspense-normal-fetch-waterfall-vyswny</a>)</figcaption></figure><p>The only thing we modified above is the position of the <code>Post</code> component where it renders. Instead of it being rendered inside the <code>App</code> component, now it renders inside the <code>User</code> component, once the <code>/users/</code> API call is resolved.</p><p>But now we can see another issue. The <code>Post</code> component doesn’t start fetching its data until <code>/users/</code> API call is resolved. This is by design but now the total loading time of the application is <code>3s + 5s</code>. This is one of the problems with waterfall data fetching patterns apart from the obvious complexity of the code it introduces.</p><p>In both cases, we have something to lose and these problems could have been easily solved if the <code>App</code> component could have managed the orchestration of its children. Well, that can be managed if <code>App</code> component itself fetches the data for <code>User</code> and <code>Post</code> component and decide when to render them.</p><figure><figcaption>(source: <a href="https://codesandbox.io/s/react-suspense