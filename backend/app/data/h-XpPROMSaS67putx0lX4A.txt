React — 5 Things That Might Surprise You<div><div><p>The React library is pretty straightforward and is relatively easy to get into, especially with the wide variety of materials that exist to help you learn it. But every tool has its share of tricks or issues that these tutorials usually don’t cover. You get to learn them when someone reviews your code, or worse — when you’re facing a problem and are desperate to find a solution. Hopefully, with this article, I might reveal some of these things about React, and maybe even surprise you!</p><figure></figure><h2>1. Setting the state by using the previous state is unpredictable.</h2><p>State management is the foundation of React, and while <code>useState</code>is probably the most common hook, there might be some unawareness of its actual behavior.</p><p>Let’s have a look at the following component:</p><figure></figure><p>What would you expect the value of the counter state to be, after a user clicks on the button?</p><p>A. 2<br />B. 1</p><p>Not sure? Try it out yourself:</p><figure><figcaption>Is it 2? Or maybe 1? What did you get?</figcaption></figure><p>Well, whether you knew that, guessed correctly. or just tested the demo — the answer is B!</p><p>The reason is that during our state update we used the previous state value: <code>setCounter(count + 1)</code>. Essentially, the state setter function is wrapped inside the functional component closure, so it is provided with the value that was captured in that closure. It means that when it will eventually be executed (the state setter function is asynchronous), it might hold a state value that is no longer relevant. On top of that, consecutive execution of setState might cause React’s scheduling algorithms to handle multiple very fast state updates using the same event handler.</p><p>The same problem might also occur when setting the state inside an asynchronous function:</p><pre>onClick={() =&gt; { <br /> setTimout(() =&gt; { setCounter(counter + 1); ), 1000);<br />}};</pre><p>But, no worries, React actually provides an easy solution to this problem — “<strong>functional updates</strong>”.</p><pre>setCounter((prevCounter) =&gt; prevCounter + 1);</pre><p>Instead of passing the value directly to <code>setCounter</code>, we pass a function. This function receives as a parameter the <strong>previous state.<br /></strong>This way we can be sure that React provides us the correct value of the previous state, and avoid the scenarios that might cause the unexpected behavior.</p><figure></figure><p><strong>Whenever your state update is relying on the previous state, be sure to use functional updates!</strong></p><p>Another benefit of this is to allow correct memoization of functions, since passing the value as a dependency would re-create the function on every state change.</p><figure></figure><h2>2. You can use useRef to store a static variable</h2><p>We are accustomed to using the ref mechanism in React as a means to access an element’s DOM node, whether because we need it to calculate its size, set a focus status, or basically do anything React can’t do naturally. But refs can also be used for a different purpose — something that we could achieve for free with class components, but we can’t with functional ones — keep a static variable that won’t be recreated on every render.</p><p>Why would we need to do so? Well, it really depends on the situation. For instance, let’s say we’re using some javascript library that was not written for React.</p><figure><figcaption>Using a ref saves the day!</figcaption></figure><p>In this example, we have a class Dog. Dog has two functions — one to set its name, and one to bark it.</p><p>If we tried to create the instance of this class using a simple variable, what would happen is that in case (for any reason) the component is re-rendered, a new instance will be created. So any changes we did so far will go away.</p><p>But by using a ref, we will be able to keep our instance