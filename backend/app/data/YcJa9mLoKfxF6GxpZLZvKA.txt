How To Manage React States Like A Pro<div><div><figure><figcaption>Photo by <a href="https://unsplash.com/@afgprogrammer?utm_source=medium&amp;utm_medium=referral">Mohammad Rahmani</a> on <a href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral">Unsplash</a></figcaption></figure><p>State management is one of the most challenging parts of the application. There are tons of state management libraries out there. Understanding how to manage states so effectively that it doesn’t affect your app performance is crucial.</p><p>The “secret” behind excellent state management is understanding how your app maps state to the app’s tree structure.</p><h2>Four mistakes commonly made with state management:</h2><ul><li>Thinking Redux is a silver bullet to every state management problem.</li><li>Storing local state in state stores like Redux.</li><li>Storing all or multiple unrelated application states in a single object.</li><li>Storing props passed to the component inside the state.</li></ul><h2><strong>Give expensive state calculation a boost</strong></h2><p>Sometimes your initial state value needs to be generated using some expensive calculation or operation, such as from local storage. This little trick can boost the performance of your application by initializing those state values using a lazy initialization technique.</p><p>The technique is straightforward when using the `useState` hook; instead of directly initializing the state, pass a function to it that will return the initial value of the state.</p><figure></figure><p>It works because creating a function is quicker than directly performing expensive computations. When you pass a function to the `useState` hook, React will only execute the function when it needs the initial value of the state.</p><h2><strong>Manage asynchronous states like a pro</strong></h2><p>Managing states when your app is doing asynchronous operations may be a pain. To solve this problem, we can use a set of techniques to handle those complex scenarios very quickly. <a href="/get-rid-of-stale-states-in-react-once-and-for-all-e52ffe09a7bd">Check out this quick guide</a> to help manage states in these difficult scenarios.</p><h2><strong>Manage complex states seamlessly</strong></h2><p>There are times when your app has complex state values. Handling those complex states becomes super easy with this small technique. It allows you to add your own custom logic to handle complex states in React seamlessly.</p><p>The technique is called the state reducer pattern. It is very simple to use. What you need to do is that you use: the `useReducer` hook. This hook allows you to pass a custom state reducer as the first parameter and an initial value as the second parameter. The reducer can use any custom logic to calculate the final state value. The value returned by the reducer will be used as the next state value.</p><figure></figure><h2><strong>Use these thumb rules for clear state management</strong></h2><ul><li>Avoid derived state. It means that you should never set values passed as props to the state. Every value should be either fully controlled (through props) or fully uncontrolled (in the local state).</li><li>Avoid making truly local state global. Ask yourself: If this component was rendered twice, should this interaction reflect in the other parts of the app? If the answer is no, then keep state local only.</li><li>To perform expensive calculations from props with performance, use the `useMemo` hook and pass those props in the list of dependencies.</li><li>Do not store all or unrelated states together in single object. It will make them difficult to manage.</li><li>Prefer using compound components when you need to share some common states in a tree of related components. <a href="/5-steps-to-build-react-components-like-a-pro-fb1f3af6ba17">Check out this guide</a> to build components like a pro.</li></ul><h2>Go composable: Build apps faster like Lego</h2><figure><a href="https://bit.cloud/"></a></figure><p><a href="https://bit.cloud/