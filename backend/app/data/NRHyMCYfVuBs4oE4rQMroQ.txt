The new wave of React state management<div><div><article><h2>Introduction</h2><p>As React applications grow in size and complexity, managing shared global state is challenging. The general advice is to only reach for global state management solutions when needed.</p><p>This post will flesh out the core problems global state management libraries need to solve.</p><p>Understanding the underlying problems will help us assess the tradeoffs made in the “new wave” of state management approaches. For everything else, it’s often better to start local and scale up only as needed.</p><p>React itself does not provide strong guidelines for solving this for shared global application state. As such, the React ecosystem has collected numerous approaches and libraries to solve this problem over time.</p><p>This can make it confusing when assessing which library or pattern to adopt.</p><p>The common approach is to outsource this and use whatever is most popular. Which as we’ll see, was the case with the widespread adoption of Redux early on, with many applications not needing it.</p><p>Understanding the problem space state management libraries operate in allows us to better understand why so many different libraries take different approaches.</p><p>Each makes different tradeoffs against different problems, leading to numerous variations in API’s, patterns, and conceptual models on how to think about state.</p><p>We’ll take a look at modern approaches and patterns that can be found in libraries like <a href="https://recoiljs.org/">Recoil</a>, <a href="https://jotai.org/">Jotai</a>, <a href="https://github.com/pmndrs/zustand">Zustand</a>, <a href="https://github.com/pmndrs/valtio">Valtio</a> and how others like <a href="https://github.com/dai-shi/react-tracked">React tracked</a> and <a href="https://react-query.tanstack.com/overview">React query</a> and how fit into the ever evolving landscape.</p><p>By the end, we should be more equipped to accurately assess libraries’ trade-offs when choosing one that makes sense for our application’s needs.</p><h2>The problems global state management libraries need to solve</h2><ol><li><p><strong>Ability to read stored state from anywhere in the component tree.</strong> This is the most basic function of a state management library.</p><p>It allows developers to persist their state in memory, and avoid the issues prop drilling has at scale. Early on in the React ecosystem we often reached for Redux unnecessarily to solve this pain point.</p><p>In practice there are two main approaches when it comes to actually storing the state.</p><p>The first is inside the React runtime. This often means leveraging API’s React provides like <code>useState</code>, <code>useRef</code> or <code>useReducer</code> combined with React context to propagate a shared value around. The main challenge here is optimizing re-renders correctly.</p><p>The second is outside of React’s knowledge, in module state. Module state allows for singleton-like state to be stored. It’s often easier to optimize re-renders through subscriptions that opt-in to re-rendering when the state changes. However, because it’s a single value in memory, you can’t have different states for different subtrees.</p></li><li><p><strong>Ability to write to stored state.</strong> A library should provide an intuitive API for both reading and writing data to the store.</p><p>An intuitive API is often one that fits ones existing mental models. So this can be somewhat subjective depending on who the consumer of the library is.</p><p>Often times clashes in mental models can cause friction in adoption or increase a learning curve. A common clashing of mental models in React is mutable versus immutable state.</p><p>React’s model of UI as a function of state lends itself to concepts that rely on referential equality and immutable updates to detect when things change so it can re-render correctly. But Javascript is a mutable language.</p><p>When using React, we have to keep things like reference equality in mind. This can be a source of confusion for Javascript developers not used to functional concepts and forms part of the learning curve when using React.</p><p>Redux follows this model and requires all state updates