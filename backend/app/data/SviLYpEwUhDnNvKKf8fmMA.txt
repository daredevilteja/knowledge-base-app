React Lazy, Suspense and Code Splitting<div><div><figure></figure><p>→ Before deployment, React JS is bundled into a <strong>single file</strong> and deployed.</p><p>→ Bundling is great, but as your <strong>app grows,</strong> your <strong>bundle will grow too</strong>. Especially if you are including large third-party libraries. You need to keep an eye on the code you are including in your bundle so that you don’t accidentally make it so large that your app takes a long time to load.</p><p>→ When we are having an application, its bundle file keeps on growing. Instead of making a 25 MB file we can split it and divide the bundle size.</p><p>→ To <strong>avoid winding up with a large bundle</strong>, it’s good to get ahead of the problem and start “<strong>splitting” your bundle</strong>. <strong>Code-Splitting is a feature</strong> supported by bundlers like <a href="https://webpack.js.org/guides/code-splitting/">Webpack</a>, <a href="https://rollupjs.org/guide/en/#code-splitting">Rollup</a> and Browserify (via <a href="https://github.com/browserify/factor-bundle">factor-bundle</a>) which can create multiple bundles that can be <strong>dynamically loaded</strong> at runtime.</p><p>→ Code-splitting your app can help you “<strong>lazy-load</strong>” just the things that are currently needed by the user, which can dramatically improve the performance of your app. While you <strong>haven’t reduced the overall amount of code</strong> in your app, you’ve avoided loading code that the user may never need, and reduced the amount of code needed during the initial load.</p><p>→ The way we can <strong>import synchronous modules.</strong></p><pre>import Foo from './Foo'; // this is for synchronous, declarative,<br /> // webpack finds it and ready it line by line</pre><p>→ The way we can <strong>load asynchronous modules</strong>. It comes with the concept of <strong>dynamic loading.</strong></p><pre>import('./Foo').<strong>then</strong>(Foo =&gt;<br /> console.<strong>log</strong>(Foo)<br />)</pre><p>→ In the application you must have used some concepts, whenever some data is fetched from API, meanwhile we have used loaders and goes away when data is fetched successfully. Easier way is using <strong>React-loadable</strong></p><p>Example:</p><p>Cast.js (Component 1)</p><figure></figure><p>Description.js (Component 2)</p><figure></figure><p>App.js (Regular Way) — Main Component</p><figure><figcaption>App.js</figcaption></figure><p>O/P:</p><figure></figure><p><strong>App.js (With Lazy Load) — Main Component</strong></p><p>→ Lazy load is the <strong>optimization trick.</strong></p><p>→ Convert regular import into asynchronous import</p><pre>var Cast = <strong>React</strong>.<strong>lazy</strong>(() =&gt; import('./Cast'));// import Cast from './Cast'; // Regular</pre><p>→ So the component which will import late should be added in &lt;Suspense&gt;. Inside Suspense Component we keep all the asynchronous components that are <strong>dynamic import.</strong></p><p>eg. purposely for the demo <strong>we delayed two components</strong> — 500 milliseconds and 1000 milliseconds. So it will load all in 1000 milliseconds</p><p>→ The <strong>React.lazy</strong> function lets you render a dynamic import as a regular component.</p><p>App.js (With lazyload)</p><figure></figure><p><strong>Conclusion:</strong></p><ol><li>Use <strong>asynchronous imports</strong> on those components which will take time to load. eg. images