React state management in 3 lines<div><article><div><p>ðŸ“Œ</p><p>I talked about my mental model about state management in React in previous <a href="/state-management-in-react">post</a>, this post is an implementation about that.</p></div><h3><a href="#5c2c9996c6c1412c9492e94a1423bb3c"></a>TL;DR</h3><ol><li><code>npm install unstated-next immer use-immer</code></li></ol><ol><li>create a <code>store.ts</code> file with 3 lines of code (ðŸ‘‡)</li><ol><pre><code>// store.ts
import { createContainer } from 'unstated-next'
import { useImmer } from 'use-immer'
export default createContainer(state =&gt; useImmer(state))</code></pre></ol></ol><ol><li>ðŸŽ‰ðŸŽ‰ðŸŽ‰</li></ol><hr /><h3><a href="#ed0c172903584e9183fded8511c6d43b"></a>Problem</h3><p>Have you ever experienced analysis paralysis in the world of React while trying to understand what <a href="https://en.wikipedia.org/wiki/The_Paradox_of_Choice">The Paradox of Choices</a> means? The fact that React is so unopinionated that it offloads the burden of having strong opinions onto you, the developer, who is responsible for building something more than a "Hello World" demo.</p><p>Every day, a new state management solution emerges, including Redux, Mobx, React.Context, Jotai, Zustand, and others. Each has its unique features, which is why there are numerous online tutorials about them. However, the question remains: which one should we choose if we want to simply Get Stuff Done (GSD) instead of getting stuck in certain rabbit holes?</p><h3><a href="#f69153cd20a94b4eb31469088ef9a5df"></a>Inspiration</h3><p>If we can suspend our judgement temporarily and let go of the pride of winning the popularity contest for a moment, we may find something quite pragmatic from our peer frameworks. And of course, we will. There will always be inspirations to draw from others, similar to how they learn from React.</p><p>In Vue 3, there is a new Composition API paired with Immer.js that literally turns Vue into React. See how Evan weaves his magic in just a few lines of code.</p><div><pre><code>const { state: items, update } = useImmer([
 {
 title: "Learn Vue",
 done: true
 },
 {
 title: "Use Vue with Immer",
 done: false
 }
])</code></pre><figcaption>Vue 3 todo example</figcaption></div><p>Although it looks simple and clean, it doesn't provide much of a selling point to me because Vue and Immer.js have many similarities in terms of state mutations, <em>from a developer point of view</em>. They both allow us to mutate state in a way that's similar to how we mutate JavaScript objects, without working against the JavaScript language.</p><p>But how about React? Could it be possible to bring the same idea to React and make React more Vue-ish?</p><h3><a href="#78f6282139f145dba3c5ca0406d26081"></a>Solution</h3><div><p>Turns out, it's not that difficult to achieve (you only need </p><p>+ </p><p>). It has the same benefit of using React.Context, but unlike hooks, state can be shared across components. What is more is that it enhances React.Context with Immer so that you can update state just like youâ€™re mutating object in javascript. </p></div><p>Additionally, Unstated Next enhances React.Context with Immer, allowing you to update state just like you would mutate an object in JavaScript. Think of it as replacing React's <code>setState</code> with Immer's <code>update</code> function, while everything else remains the same.</p><div><pre><code>import store from './store'
// useContainer is a React hook from https