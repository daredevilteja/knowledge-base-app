Managing State<div><div><div><p>As your application grows, it helps to be more intentional about how your state is organized and how the data flows between your components. Redundant or duplicate state is a common source of bugs. In this chapter, you’ll learn how to structure your state well, how to keep your state update logic maintainable, and how to share state between distant components.</p>
<h2>Reacting to input with state <a href="#reacting-to-input-with-state"></a></h2>
<p>With React, you won’t modify the UI from code directly. For example, you won’t write commands like “disable the button”, “enable the button”, “show the success message”, etc. Instead, you will describe the UI you want to see for the different visual states of your component (“initial state”, “typing state”, “success state”), and then trigger the state changes in response to user input. This is similar to how designers think about UI.</p>
<p>Here is a quiz form built using React. Note how it uses the <code>status</code> state variable to determine whether to enable or disable the submit button, and whether to show the success message instead.</p>
</div><div><pre>import { useState } from 'react';
export default function Form() {
 const [answer, setAnswer] = useState('');
 const [error, setError] = useState(null);
 const [status, setStatus] = useState('typing');
 if (status === 'success') {
 return &lt;h1&gt;That's right!&lt;/h1&gt;
 }
 async function handleSubmit(e) {
 e.preventDefault();
 setStatus('submitting');
 try {
 await submitForm(answer);
 setStatus('success');
 } catch (err) {
 setStatus('typing');
 setError(err);
 }
 }
 function handleTextareaChange(e) {
 setAnswer(e.target.value);
 }
 return (
 &lt;&gt;
 &lt;h2&gt;City quiz&lt;/h2&gt;
 &lt;p&gt;
 In which city is there a billboard that turns air into drinkable water?
 &lt;/p&gt;
 &lt;form onSubmit={handleSubmit}&gt;
 &lt;textarea
 value={answer}
 onChange={handleTextareaChange}
 disabled={status === 'submitting'}
 /&gt;
 &lt;br /&gt;
 &lt;button disabled={
 answer.length === 0 ||
 status === 'submitting'
 }&gt;
 Submit
 &lt;/button&gt;
 {error !== null &amp;&amp;
 &lt;p className="Error"&gt;
 {error.message}
 &lt;/p&gt;
 }
 &lt;/form&gt;
 &lt;/&gt;
 );
}
function submitForm(answer) {
 
 return new Promise((resolve, reject) =&gt; {
 setTimeout(() =&gt; {
 let shouldError = answer.toLowerCase() !== 'lima'
 if (shouldError) {
 reject(new Error('Good guess but a wrong answer. Try again!'));
 } else {
 resolve();
 }
 }, 1500);
 });
}
</pre></div><div>
<hr />
<h2>Choosing the state structure <a href="#choosing-the-state-structure"></a></h2>
<p>Structuring state well can make a difference between a component that is pleasant to modify and debug, and one that is a constant source of bugs. The most important principle is that state shouldn’t contain redundant or duplicated information. If there’s some unnecessary state, it’s easy to forget to update it, and introduce bugs!</p>
<p>For example, this form has a <strong>redundant</strong> <code>fullName</code> state variable:</p>
</div><div><pre>import { useState } from 'react';
export default function Form() {
 const [firstName, setFirstName] = useState('');
 const [lastName, setLastName] = useState