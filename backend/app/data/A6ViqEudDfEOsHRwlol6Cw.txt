Demystifying state management<div><div>
 <p>
 </p>
 <div>
 <p><a href="/kevtiq"></a>
 </p>
 
 </div>
 </div><div>
 <p>State management is one of the most complicated, and opinionated topics in modern and JavaScript-focused front-end development. But at its core, it is not that complicated. We just make it complicated. In this article I will try to demystify state and state management for you, and challenge your mental models around them. </p>
<h2>
 <a href="#what-are-state-and-state-management">
 </a>
 What are state and state management?
</h2>
<p>Is state some weird data storage? Is it the data from a database? No. State is nothing more than a JavaScript value that lives within in scope. It can be a boolean, a string, but is in most cases a (complex) object. But it remains a value. In most cases, it is even an object living on the same level as the <code>window</code> object. It has become a global value in the JavaScript environment, the browser window. From our code (e.g. UI components), we can use this value to determine what to show or what interactions to allow. In complex applications there are a few different types of state we can have. But remember, they are nothing more than values. </p>
<ul>
<li>
<strong>Local</strong>: state that is used by a single UI component.</li>
<li>
<strong>Shared</strong>: state that is used by many UI components. It is often managed in a parent or wrapper component.</li>
<li>
<strong>Global</strong>: a special kind of <em>shared</em> state, as it lives on the highest level, accessible to all UI components (or even helper functions).</li>
<li>
<strong>Meta</strong>: also known as 'state about state'. It tells you something about</li>
<li>
<strong>Route</strong>: state stored in the current URL of the application (e.g. object IDs or pagination information).</li>
<li>
<strong>Remote</strong>: a copy of the data coming from a server. The responses of fetch requests are stored as 1-on-1 copies in this state. It should not deviate from the server (except when applying <a href="https://www.smashingmagazine.com/2016/11/true-lies-of-optimistic-user-interfaces/">optimistic UI</a>).</li>
</ul>
<p>So what about state management? For many, state management feels like a black box. What is happening within Redux? Why does it feel so complicated. I look at it this way: state management is nothing more than patterns we use to make using and changing state, manageable. It is not black box magic, it is just patterns. Why not group all the mutations you can make on your state in one place? And how about giving these mutations simple, but understandable names? In complex applications, adopting these types of patterns makes our code more maintainable. Or so they say (it is true though). In the sections below, we go deeper into different kind of state management patterns. </p>
<h2>
 <a href="#eventdriven-pattern">
 </a>
 Event-driven pattern
</h2>
<p>The best-known pattern is the flux pattern. It gained popularity with the 'Redux' package. It is a great example of an event-driven pattern. Let's take a closer look at its flow. The user, via the view, dispatches an action, via an action creator. It might seem daunting or overly complex. But it is nothing more as I said before. It is a way to group all possible state mutations together, and allow us to use simple 'actions' with memorable names from our UI components. </p>
<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--N33N6ZEZ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7xa0exqvu0q9y708fbjz.png"></a></