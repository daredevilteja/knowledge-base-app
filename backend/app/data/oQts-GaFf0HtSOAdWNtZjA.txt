React18: Whatâ€™s new?<div><div><article><div><div><figure></figure><p>There are 3 major API update and all three are going to impress you.</p><ul><li><strong>Transition</strong></li><li><strong>Batching</strong>, Automatic batching for fewer renders</li><li><strong>Suspense</strong>, SSR support for Suspense</li></ul><h2>Transition</h2><p>If you have two states to render two component, which component should get more priority?</p><pre>setChart(chartInput); // let's say it is Urgent updates<br />setTable(tableResult); // let's say it is Transition updates</pre><p>We classify state updates in two categories:</p><ul><li><strong>Urgent updates reflect direct interaction,</strong> like typing, clicking, pressing, and so on.</li><li><strong>Transition updates</strong> transition the UI from one view to another.</li></ul><p><strong>In React 18 version</strong>, use <code>startTransition</code>, now you can control the priority of component. This is great right ?</p><p>React offers a new built-in <code>useTransition()</code> Hook to help with this.</p><p>Our <code>useTransition()</code> call returns two values: <code>startTransition</code> and <code>isPending</code>.</p><pre>const [<strong>startTransition</strong>, <strong>isPending</strong>] = <strong>useTransition</strong>({ timeoutMs: 3000 });</pre><blockquote><p>Wrapping setState in a Transition</p></blockquote><pre>// Priority 1, urgent update<br />setChart(input);<p>// Priority 2, not so urgent update<br /><strong>startTransition</strong>( () =&gt; {<br /> setTable(tableResult);<br />})</p></pre><p>Updates wrapped in <code>startTransition</code> are handled as non-urgent and will be interrupted if more urgent updates like clicks or key presses come in.</p><h2>Where can I use it?</h2><ul><li>You can use <code>startTransition</code> to wrap any update that you want to move to the background.</li></ul><p><strong>These type of updates fall into two categories:</strong></p><ul><li><strong>Slow rendering: </strong>These updates take time because React needs to perform a lot of work in order to transition the UI to show the results.</li><li><strong>Slow network: </strong>These updates take time because React is waiting for some data from the network. This use case is tightly integrated with Suspense.</li></ul></div><div><h2>Batching, <strong>use </strong><code><strong>flushSync()</strong></code></h2><ul><li>Batching is when React groups multiple state updates into a single re-render for better performance. This is great for performance because it avoids unnecessary re-renders.</li><li>or, Batching is the process in which react holds to send a DOM re-render call. They collect a few state update events that are happening in same function call and sends just 1 call to update the DOM.</li><li>We only batched updates during the React event handlers. Updates inside of promises, setTimeout, native event handlers, or any other event were not batched in React by default.</li><li>Example, It will be fired at the end of all state changes.</li></ul><pre>const demoApp = () =&gt; {<br /> const [b1, setButtonOne] = useState('green');<br /> const [b2, setButtonTwo] = useState('Orange');<br /> const [b2, setButtonThree] = useState('pink');<p> const handleClick = () =&gt; {<br /> setButtonOne('white'); //NOT YET<br /> setButtonTwo('white'); // NOT YET<br /> setButtonThree('white')<br /> //Now re render<br /> }</p><p> return(<br /> &lt;&gt;<br /> &lt;