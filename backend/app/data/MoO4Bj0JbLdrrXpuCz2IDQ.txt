How to avoid tricky async state manager pitfalls in React—Martian Chronicles, Evil Martians’ team blog<div><div><p>These days, the local-first approach for building web apps is gaining more and more popularity. Most of these databases provide async APIs, and that make a big difference with our React apps. Read on to find out how to nip any potential problems in the bud.</p><p>Let’s recap the local-first approach for building web applications. When building apps this way, user data is stored locally. This means that it’s rapidly accessible, and thus, we can abstract away all the server communication and network error handling.</p><p>A core part of local-first applications are local databases. These provide APIs for our apps to read and write data, and we can also use the API to subscribe to look out for changes as well as synchronize changes over the network with the server, other users, or instances of the app in other browser tabs. </p><p>Examples include <a href="/products/logux">Logux</a>, <a href="https://replicache.dev/">Replicache</a>, <a href="https://rxdb.info/">RxDB</a>, and <a href="https://github.com/Nozbe/WatermelonDB">WatermelonDB</a>.</p><figure><div></div></figure><h2>The problem with local-first databases async APIs</h2><p>These databases provide asynchronous APIs. This means that any changes made are not applied immediately, and during this time, it’s possible for stale data to be read.</p><p>Even though this time lag is very small, it makes a big difference for React. When changes and their corresponding effects happen asynchronously, many familiar patterns (like controlled text fields or transitions) will cease to functon correctly.</p><p>To illustrate the problem, let’s imagine we want to create a text field with persistency. It will be connected to a fictitious storage called <code>MyStorage</code> (which represents a local database) and text content will be saved in this storage upon each change.</p><h2>Synchronous example</h2><p>Assuming <code>MyStorage</code> is synchronous, the code will be very simple, and familiar to every React developer:</p><div><pre><code>function PersistedTextField() {
	const [text, setText] = useMyStorage()
	return &lt;input value={text} onChange={(event) =&gt; setText(event.target.value)} /&gt;
}</code></pre></div><h2>Text fields and asynchronous storage</h2><p>However, If <code>MyStorage</code> has an asynchronous API, then the pattern above won’t work as expected: instead, every keystroke will reset the cursor position to the end of the text field. This makes it very troublesome to fix a typo in the middle of the text. </p><figure></figure><p>Let’s unpack why this happens. </p><p>Each keystroke has two effects: </p><ol><li>The value of the input component in the DOM (and the virtual DOM) is updated.</li><li>The <code>onChange</code> handler is called to update storage.</li></ol><p>Immediately after this, React performs its reconciliation cycle by comparing the value in the virtual DOM with the value in storage. Since the storage has not yet been updated, React notes the difference and rolls back the DOM value of the input to the previous state. </p><p>After the value has been saved to storage, React does the same thing again and finally applies the new value. </p><p>This happens very fast, but during this same period of time, React updates the input’s value programmatically two times. And this programmatic update has the side effect of reseting the cursor position to the end of the input.</p><p>To further clarify the contrast with the previous example, with the synchronous API, React will see the updated value in the DOM as well as the updated value in storage; this means it doesn’t have to update anything programmatically.</p><h2>Further issues with asynchronous storages</h2><p>Let’s look at another place where a problem caused by asynchronous API can crop up: animations during drag-and-drop sorting. </p><p>Imagine a